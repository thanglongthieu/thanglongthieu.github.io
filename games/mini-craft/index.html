<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini-Craft 3D World</title>
  <!-- iPhone 向けフルスクリーン系設定 -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050608;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-text-size-adjust: 100%;
    }

    body {
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing: border-box;
    }

    #game {
      width: 100%;
      height: 100%;
      touch-action: none;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.55);
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.4;
      pointer-events: none;
      max-width: 260px;
    }

    #hud strong {
      color: #ffeb3b;
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="hud">
      <strong>Mini-Craft 3D</strong><br />
      Move: WASD / Arrow keys<br />
      Look: Drag (touch / mouse)<br />
      Zoom: Pinch / Mouse wheel<br />
      Explore the house & furniture!
    </div>
  </div>

  <!-- Three.js & OrbitControls (ES Modules, URL 参照なので import エラー出ない) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ====== BASIC SETUP ======
    const container = document.getElementById("game");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // blue sky

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(10, 8, 14);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.target.set(0, 2, 0);
    controls.maxPolarAngle = Math.PI / 2; // 下を向きすぎない
    controls.minDistance = 4;
    controls.maxDistance = 40;

    // ====== LIGHTS ======
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(10, 20, 5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 60;
    dirLight.shadow.camera.left = -30;
    dirLight.shadow.camera.right = 30;
    dirLight.shadow.camera.top = 30;
    dirLight.shadow.camera.bottom = -30;
    scene.add(dirLight);

    const warmLight = new THREE.PointLight(0xffddaa, 1.2, 25);
    warmLight.position.set(0, 6, 0);
    warmLight.castShadow = true;
    scene.add(warmLight);

    // ====== PLAYER ======
    const player = {
      position: new THREE.Vector3(0, 1, 10),
      speed: 8,
    };

    const playerGeometry = new THREE.BoxGeometry(0.8, 1.4, 0.8);
    const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
    const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
    playerMesh.castShadow = true;
    playerMesh.position.copy(player.position);
    scene.add(playerMesh);

    // ====== HELPERS ======
    function createBlock(x, y, z, color, sx = 1, sy = 1, sz = 1) {
      const geo = new THREE.BoxGeometry(sx, sy, sz);
      const mat = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.set(x, y + sy / 2, z); // y は中心
      scene.add(mesh);
      return mesh;
    }

    // ====== WORLD / GROUND ======
    function createGround() {
      const size = 20;
      for (let x = -size; x <= size; x++) {
        for (let z = -size; z <= size; z++) {
          const color = (x + z) % 2 === 0 ? 0x4caf50 : 0x43a047;
          createBlock(x, 0, z, color, 1, 0.25, 1);
        }
      }
    }

    // ====== HOUSE & FURNITURE ======
    function createHouseAndFurniture() {
      // --- wood floor ---
      for (let x = -4; x <= 4; x++) {
        for (let z = -4; z <= 4; z++) {
          createBlock(x, 0.13, z, 0x8d6e63, 1, 0.1, 1);
        }
      }

      const wallHeight = 4;

      // Back wall (z = -4.5)
      for (let x = -4; x <= 4; x++) {
        for (let y = 0; y < wallHeight; y++) {
          createBlock(x, 0.25 + y, -4.5, 0xd7ccc8, 1, 1, 0.2);
        }
      }

      // Front wall (z = 4.5) with door opening
      for (let x = -4; x <= 4; x++) {
        for (let y = 0; y < wallHeight; y++) {
          const isDoorArea = x === 0 && y <= 2;
          if (isDoorArea) continue;
          createBlock(x, 0.25 + y, 4.5, 0xd7ccc8, 1, 1, 0.2);
        }
      }

      // Left wall (x = -4.5)
      for (let z = -4; z <= 4; z++) {
        for (let y = 0; y < wallHeight; y++) {
          createBlock(-4.5, 0.25 + y, z, 0xd7ccc8, 0.2, 1, 1);
        }
      }

      // Right wall (x = 4.5) with small window
      for (let z = -4; z <= 4; z++) {
        for (let y = 0; y < wallHeight; y++) {
          const isWindowArea = z >= -1 && z <= 1 && (y === 1 || y === 2);
          if (isWindowArea) continue;
          createBlock(4.5, 0.25 + y, z, 0xd7ccc8, 0.2, 1, 1);
        }
      }

      // Roof
      for (let x = -4.5; x <= 4.5; x++) {
        for (let z = -4.5; z <= 4.5; z++) {
          createBlock(x, wallHeight + 0.3, z, 0x6d4c41, 1, 0.2, 1);
        }
      }

      // ===== Furniture =====
      createTable(0, 0.25, 0);
      createChair(-1.5, 0.25, 0);
      createChair(1.5, 0.25, 0);
      createChair(0, 0.25, -1.5);
      createChair(0, 0.25, 1.5);
      createBed(-3, 0.25, -3);
      createBookshelf(3.7, 0.25, -2);
      createChest(3, 0.25, 3);
      createLamp(-2.7, 0.25, 1.5);
    }

    function createTable(x, y, z) {
      const legHeight = 1.0;
      const legOffset = 0.9;
      const legRadius = 0.15;
      createBlock(x - legOffset, y, z - legOffset, 0x5d4037, legRadius, legHeight, legRadius);
      createBlock(x + legOffset, y, z - legOffset, 0x5d4037, legRadius, legHeight, legRadius);
      createBlock(x - legOffset, y, z + legOffset, 0x5d4037, legRadius, legHeight, legRadius);
      createBlock(x + legOffset, y, z + legOffset, 0x5d4037, legRadius, legHeight, legRadius);
      createBlock(x, y + legHeight, z, 0x8d6e63, 2.2, 0.15, 2.2);
    }

    function createChair(x, y, z) {
      const seatHeight = 0.6;
      const seatSize = 0.7;
      const legRadius = 0.1;
      const legOffset = 0.3;
      createBlock(x - legOffset, y, z - legOffset, 0x5d4037, legRadius, seatHeight, legRadius);
      createBlock(x + legOffset, y, z - legOffset, 0x5d4037, legRadius, seatHeight, legRadius);
      createBlock(x - legOffset, y, z + legOffset, 0x5d4037, legRadius, seatHeight, legRadius);
      createBlock(x + legOffset, y, z + legOffset, 0x5d4037, legRadius, seatHeight, legRadius);
      createBlock(x, y + seatHeight, z, 0x8d6e63, seatSize, 0.12, seatSize);
      createBlock(x, y + seatHeight + 0.5, z - 0.3, 0x6d4c41, seatSize, 1.0, 0.12);
    }

    function createBed(x, y, z) {
      createBlock(x, y, z, 0x5d4037, 2.2, 0.3, 1.1);
      createBlock(x, y + 0.3, z, 0xfff8e1, 2.0, 0.3, 1.0);
      createBlock(x + 0.7, y + 0.45, z, 0xffffff, 0.6, 0.25, 0.9);
      createBlock(x - 0.4, y + 0.45, z, 0x2196f3, 1.2, 0.2, 0.9);
    }

    function createBookshelf(x, y, z) {
      createBlock(x, y + 1.5, z, 0x5d4037, 0.6, 3, 1.6);
      const shelfColors = [0xffcc80, 0x90caf9, 0xffab91, 0xa5d6a7];
      for (let i = 0; i < 4; i++) {
        const sy = y + 0.5 + i * 0.7;
        createBlock(x + 0.05, sy, z, shelfColors[i], 0.4, 0.15, 1.4);
      }
    }

    function createChest(x, y, z) {
      createBlock(x, y, z, 0x795548, 1.2, 0.6, 0.9);
      createBlock(x, y + 0.6, z, 0x6d4c41, 1.2, 0.25, 0.9);
      createBlock(x + 0.55, y + 0.35, z, 0xffd54f, 0.12, 0.2, 0.12);
    }

    function createLamp(x, y, z) {
      createBlock(x, y, z, 0x424242, 0.12, 1.8, 0.12);
      createBlock(x, y + 1.8, z, 0xfff3e0, 0.6, 0.4, 0.6);
      const lampLight = new THREE.PointLight(0xfff3b0, 1.5, 8);
      lampLight.position.set(x, y + 2.1, z);
      scene.add(lampLight);
    }

    // ====== SCENE CREATION ======
    createGround();
    createHouseAndFurniture();

    function createTree(tx, tz) {
      const trunkHeight = 2;
      createBlock(tx, 0.25, tz, 0x5d4037, 0.4, trunkHeight, 0.4);
      createBlock(tx, 0.25 + trunkHeight, tz, 0x2e7d32, 2, 1.4, 2);
    }

    createTree(-10, -5);
    createTree(12, -8);
    createTree(-12, 6);
    createTree(8, 10);

    // ====== INPUT ======
    const keys = { forward: false, backward: false, left: false, right: false };

    function handleKeyDown(e) {
      switch (e.key.toLowerCase()) {
        case "w":
        case "arrowup":
          keys.forward = true;
          break;
        case "s":
        case "arrowdown":
          keys.backward = true;
          break;
        case "a":
        case "arrowleft":
          keys.left = true;
          break;
        case "d":
        case "arrowright":
          keys.right = true;
          break;
      }
    }
    function handleKeyUp(e) {
      switch (e.key.toLowerCase()) {
        case "w":
        case "arrowup":
          keys.forward = false;
          break;
        case "s":
        case "arrowdown":
          keys.backward = false;
          break;
        case "a":
        case "arrowleft":
          keys.left = false;
          break;
        case "d":
        case "arrowright":
          keys.right = false;
          break;
      }
    }
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    // ====== ANIMATION LOOP ======
    const clock = new THREE.Clock();

    function updatePlayer(delta) {
      const moveDir = new THREE.Vector3();
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      camDir.y = 0;
      camDir.normalize();

      const rightDir = new THREE.Vector3();
      rightDir.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

      if (keys.forward) moveDir.add(camDir);
      if (keys.backward) moveDir.sub(camDir);
      if (keys.left) moveDir.sub(rightDir);
      if (keys.right) moveDir.add(rightDir);

      if (moveDir.lengthSq() > 0) {
        moveDir.normalize();
        const speed = player.speed * delta;
        player.position.addScaledVector(moveDir, speed);
        player.position.y = 1; // 簡易：常に床の高さ
        playerMesh.position.copy(player.position);
        const angle = Math.atan2(moveDir.x, moveDir.z);
        playerMesh.rotation.y = angle;
      }

      controls.target.lerp(player.position, 0.1);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      updatePlayer(delta);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ====== RESIZE ======
    function onResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", () => {
      setTimeout(onResize, 300);
    });
  </script>
</body>
</html>
