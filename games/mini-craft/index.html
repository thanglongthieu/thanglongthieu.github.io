<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini-Craft Style Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #20232a;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    #gameCanvas {
      display: block;
      background: #6ec6ff;
    }

    .ui {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.4;
    }

    .ui strong {
      color: #ffeb3b;
    }

    .toolbar {
      margin-top: 6px;
      display: flex;
      gap: 4px;
    }

    .slot {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 2px solid #aaa;
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
    }

    .slot.selected {
      border-color: #ffeb3b;
      box-shadow: 0 0 6px #ffeb3b;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui">
    <div><strong>Mini-Craft Style</strong></div>
    <div>Move: WASD / Arrow keys</div>
    <div>Jump: W / ↑ / Space</div>
    <div>Break block: Left Click</div>
    <div>Place block: Right Click or Shift + Left Click</div>
    <div>Change block type: 1 (Grass), 2 (Dirt), 3 (Stone)</div>

    <div class="toolbar">
      <div class="slot selected" data-block="1" title="Grass">1</div>
      <div class="slot" data-block="2" title="Dirt">2</div>
      <div class="slot" data-block="3" title="Stone">3</div>
    </div>
  </div>

  <script>
    // ===== BASIC SETUP =====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const TILE_SIZE = 32;
    const WORLD_WIDTH = 80;
    const WORLD_HEIGHT = 40;

    // 0 = 空, 1 = 草, 2 = 土, 3 = 石
    const BLOCK_COLORS = {
      0: null,
      1: "#4caf50",
      2: "#8d6e63",
      3: "#9e9e9e",
    };

    // ===== WORLD GENERATION =====
    const world = [];

    function generateWorld() {
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        world[y] = [];
        for (let x = 0; x < WORLD_WIDTH; x++) {
          // 地面の高さ
          const groundLevel = 20 + Math.floor(Math.sin(x / 5) * 2);
          if (y > groundLevel + 4) {
            world[y][x] = 3; // stone
          } else if (y > groundLevel) {
            world[y][x] = 2; // dirt
          } else if (y === groundLevel) {
            world[y][x] = 1; // grass
          } else {
            world[y][x] = 0; // air
          }
        }
      }

      // ちょっとだけ木っぽいものを追加
      for (let i = 5; i < WORLD_WIDTH; i += 15) {
        const baseY = 18;
        if (baseY >= 0 && baseY < WORLD_HEIGHT) {
          for (let t = 0; t < 4; t++) {
            if (baseY - t >= 0) world[baseY - t][i] = 3; // trunk
          }
          for (let dy = -5; dy <= -2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
              const xx = i + dx;
              const yy = baseY + dy;
              if (
                xx >= 0 &&
                xx < WORLD_WIDTH &&
                yy >= 0 &&
                yy < WORLD_HEIGHT
              ) {
                if (Math.abs(dx) + Math.abs(dy + 3) <= 4) {
                  world[yy][xx] = 1; // leaves (grass color)
                }
              }
            }
          }
        }
      }
    }

    generateWorld();

    // ===== PLAYER =====
    const player = {
      x: 5,
      y: 5,
      width: 0.6, // タイル比
      height: 0.9,
      vx: 0,
      vy: 0,
      speed: 5,
      jumpPower: 10,
      onGround: false,
    };

    // ==== CAMERA ====
    const camera = {
      x: 0,
      y: 0,
    };

    function updateCamera() {
      const halfWidth = canvas.width / 2 / TILE_SIZE;
      const halfHeight = canvas.height / 2 / TILE_SIZE;

      camera.x = player.x - halfWidth;
      camera.y = player.y - halfHeight;

      camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - 2 * halfWidth));
      camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - 2 * halfHeight));
    }

    // ===== INPUT =====
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;

      // Number keys for block
      if (e.key === "1" || e.key === "2" || e.key === "3") {
        selectedBlock = parseInt(e.key, 10);
        updateToolbarSelection();
      }
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // ===== MOUSE / BLOCK EDIT =====
    let mouseX = 0;
    let mouseY = 0;
    let selectedBlock = 1;

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault(); // disable right-click menu
    });

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const worldX = Math.floor(camera.x + mx / TILE_SIZE);
      const worldY = Math.floor(camera.y + my / TILE_SIZE);

      if (
        worldX < 0 ||
        worldX >= WORLD_WIDTH ||
        worldY < 0 ||
        worldY >= WORLD_HEIGHT
      ) {
        return;
      }

      const isRightClick = e.button === 2;
      const isShiftLeft =
        e.button === 0 && (e.shiftKey || keys["shift"]);

      if (isRightClick || isShiftLeft) {
        // PLACE BLOCK
        // プレイヤーと重なる場所には置かない
        if (!isCollidingWithPlayer(worldX, worldY)) {
          world[worldY][worldX] = selectedBlock;
        }
      } else if (e.button === 0) {
        // LEFT CLICK = BREAK
        world[worldY][worldX] = 0;
      }
    });

    // Toolbar click
    document.querySelectorAll(".slot").forEach((slot) => {
      slot.addEventListener("click", () => {
        selectedBlock = parseInt(slot.dataset.block, 10);
        updateToolbarSelection();
      });
    });

    function updateToolbarSelection() {
      document.querySelectorAll(".slot").forEach((slot) => {
        const val = parseInt(slot.dataset.block, 10);
        slot.classList.toggle("selected", val === selectedBlock);
      });
    }

    // ===== PHYSICS & COLLISION =====
    const GRAVITY = 25;
    const FRICTION = 0.8;
    const MAX_FALL_SPEED = 30;
    const MAX_DELTA = 0.05; // avoid crazy dt

    function tileAt(x, y) {
      if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) {
        return 3; // treat outside as solid
      }
      return world[y][x];
    }

    function isSolid(x, y) {
      return tileAt(x, y) !== 0;
    }

    function rectCollidesWithWorld(px, py, pw, ph) {
      // Check tiles around
      const left = Math.floor(px);
      const right = Math.floor(px + pw);
      const top = Math.floor(py);
      const bottom = Math.floor(py + ph);
      for (let y = top; y <= bottom; y++) {
        for (let x = left; x <= right; x++) {
          if (isSolid(x, y)) return true;
        }
      }
      return false;
    }

    function isCollidingWithPlayer(tx, ty) {
      const px = player.x;
      const py = player.y;
      const pw = player.width;
      const ph = player.height;
      const tileLeft = tx;
      const tileRight = tx + 1;
      const tileTop = ty;
      const tileBottom = ty + 1;

      const playerLeft = px;
      const playerRight = px + pw;
      const playerTop = py;
      const playerBottom = py + ph;

      return !(
        playerRight <= tileLeft ||
        playerLeft >= tileRight ||
        playerBottom <= tileTop ||
        playerTop >= tileBottom
      );
    }

    let lastTime = performance.now();

    function gameLoop(now) {
      const dt = Math.min((now - lastTime) / 1000, MAX_DELTA);
      lastTime = now;

      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    function update(dt) {
      // Input -> velocity
      let move = 0;
      if (keys["a"] || keys["arrowleft"]) move -= 1;
      if (keys["d"] || keys["arrowright"]) move += 1;

      player.vx = move * player.speed;

      // Jump
      const jumpPressed =
        keys["w"] || keys["arrowup"] || keys[" "] || keys["space"];
      if (jumpPressed && player.onGround) {
        player.vy = -player.jumpPower;
        player.onGround = false;
      }

      // Gravity
      player.vy += GRAVITY * dt;
      if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;

      // Horizontal move
      let newX = player.x + player.vx * dt;
      if (!rectCollidesWithWorld(newX, player.y, player.width, player.height)) {
        player.x = newX;
      } else {
        // stop at wall
        while (
          !rectCollidesWithWorld(
            player.x + Math.sign(player.vx) * 0.01,
            player.y,
            player.width,
            player.height
          )
        ) {
          player.x += Math.sign(player.vx) * 0.01;
        }
        player.vx = 0;
      }

      // Vertical move
      let newY = player.y + player.vy * dt;
      player.onGround = false;
      if (!rectCollidesWithWorld(player.x, newY, player.width, player.height)) {
        player.y = newY;
      } else {
        // landing or hitting ceiling
        if (player.vy > 0) {
          // landing on ground
          player.onGround = true;
        }
        while (
          !rectCollidesWithWorld(
            player.x,
            player.y + Math.sign(player.vy) * 0.01,
            player.width,
            player.height
          )
        ) {
          player.y += Math.sign(player.vy) * 0.01;
        }
        player.vy = 0;
      }

      updateCamera();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Sky gradient
      const skyGradient = ctx.createLinearGradient(
        0,
        0,
        0,
        canvas.height
      );
      skyGradient.addColorStop(0, "#90caf9");
      skyGradient.addColorStop(1, "#e1f5fe");
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Visible tile range
      const startX = Math.floor(camera.x);
      const endX = Math.ceil(camera.x + canvas.width / TILE_SIZE);
      const startY = Math.floor(camera.y);
      const endY = Math.ceil(camera.y + canvas.height / TILE_SIZE);

      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) continue;
          const block = world[y][x];
          if (block === 0) continue;
          const screenX = (x - camera.x) * TILE_SIZE;
          const screenY = (y - camera.y) * TILE_SIZE;

          ctx.fillStyle = BLOCK_COLORS[block] || "#000";
          ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = "rgba(0,0,0,0.15)";
          ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
        }
      }

      // Player
      const playerScreenX = (player.x - camera.x) * TILE_SIZE;
      const playerScreenY = (player.y - camera.y) * TILE_SIZE;
      ctx.fillStyle = "#ffeb3b";
      ctx.fillRect(
        playerScreenX,
        playerScreenY,
        player.width * TILE_SIZE,
        player.height * TILE_SIZE
      );
      ctx.strokeStyle = "#000";
      ctx.strokeRect(
        playerScreenX,
        playerScreenY,
        player.width * TILE_SIZE,
        player.height * TILE_SIZE
      );

      // Cursor highlight tile
      const worldX = Math.floor(camera.x + mouseX / TILE_SIZE);
      const worldY = Math.floor(camera.y + mouseY / TILE_SIZE);
      const cursorX = (worldX - camera.x) * TILE_SIZE;
      const cursorY = (worldY - camera.y) * TILE_SIZE;

      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(cursorX, cursorY, TILE_SIZE, TILE_SIZE);
    }

    // Start game
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
