<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MiniCraft â€“ Fullscreen iPhone Landscape</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    #gameContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    canvas#gameCanvas {
      background: #66bb6a;
      image-rendering: pixelated;
      border: 2px solid #444;
      touch-action: none;
      display: block;
      width: 100vw;
      /* height is controlled from JS (resizeCanvas) */
    }

    /* TOP inventory + search + save/load */
    #uiBar {
      background: #222;
      padding: 6px 10px;
      font-size: 13px;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) auto;
      gap: 8px;
      align-items: stretch;
      border-top: 1px solid #333;
      box-sizing: border-box;
    }

    #inventoryPanel {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    #inventoryHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      font-size: 12px;
    }

    #blockSearch {
      flex: 1;
      padding: 3px 6px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #eee;
      font-size: 12px;
    }

    #inventoryList {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-height: 80px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .slot {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      border-radius: 6px;
      border: 2px solid #555;
      box-sizing: border-box;
      background: #333;
      cursor: pointer;
      user-select: none;
      font-size: 20px;
    }
    .slot span.slot-emoji {
      pointer-events: none;
    }
    .slot.selected {
      border-color: #ffeb3b;
      box-shadow: 0 0 8px #ffeb3b;
    }
    .slot-name {
      font-size: 9px;
      color: #ccc;
      text-align: center;
      pointer-events: none;
      line-height: 1.1;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #help {
      font-size: 11px;
      color: #ccc;
      align-self: center;
    }

    #saveLoadButtons {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-end;
      justify-content: center;
    }

    button {
      background: #424242;
      border: 1px solid #666;
      border-radius: 4px;
      color: #eee;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
    }
    button:active {
      background: #616161;
    }

    /* Touch controls for mobile (bottom) */
    #touchControls {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 6px 0 8px;
      gap: 12px;
      background: #181818;
      border-top: 1px solid #333;
      box-sizing: border-box;
    }
    #dpad {
      display: grid;
      grid-template-columns: 40px 40px 40px;
      grid-template-rows: 40px 40px 40px;
      gap: 4px;
    }
    .dpad-btn {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #303030;
      border-radius: 6px;
      border: 1px solid #555;
      font-size: 18px;
      user-select: none;
    }
    .dpad-btn:active {
      background: #505050;
    }
    .dpad-empty {
      background: transparent;
      border: none;
    }
    #touchActions {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .touch-action-btn {
      width: 80px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: #37474f;
      border: 1px solid #607d8b;
      font-size: 12px;
      user-select: none;
    }
    .touch-action-btn:active {
      background: #546e7a;
    }

    /* Hide touch controls on big screens */
    @media (min-width: 768px) {
      #touchControls {
        display: none;
      }
    }

    @media (max-width: 600px) {
      #uiBar {
        grid-template-columns: minmax(0, 1.7fr) minmax(0, 1.3fr);
        grid-template-rows: auto auto;
      }
      #saveLoadButtons {
        flex-direction: row;
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
  </div>

  <!-- Mobile / touch controls -->
  <div id="touchControls">
    <div id="dpad">
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="0,-1">â–²</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="-1,0">â—€</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="1,0">â–¶</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="0,1">â–¼</div>
      <div class="dpad-empty"></div>
    </div>
    <div id="touchActions">
      <div class="touch-action-btn" data-action="place">Place</div>
      <div class="touch-action-btn" data-action="remove">Remove</div>
      <div class="touch-action-btn" data-action="hit">Hit</div>
    </div>
  </div>

  <!-- Inventory + search + save/load -->
  <div id="uiBar">
    <div id="inventoryPanel">
      <div id="inventoryHeader">
        <span>Furniture (click to select)</span>
        <input id="blockSearch" type="text" placeholder="Search: bed, sofa, lamp..." />
      </div>
      <div id="inventoryList"></div>
    </div>
    <div id="help">
      PC: WASD/Arrows move, Space = Place, X = Remove, Z = Hit mob, 1=Wall, 2/3/4 = quick furniture.  
      Mobile: Rotate to landscape â†’ D-pad + Place / Remove / Hit.
    </div>
    <div id="saveLoadButtons">
      <button id="saveBtn">ğŸ’¾ Save World</button>
      <button id="loadBtn">ğŸ“‚ Load World</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const TILE_SIZE = 32;
    let VIEW_W = 25; // will be recalculated
    let VIEW_H = 15;

    // Big world
    const WORLD_W = 200;
    const WORLD_H = 200;

    // Camera (top-left world tile of the visible area)
    let cameraX = 0;
    let cameraY = 0;

    // ---------- BIOMES ----------
    const BIOME_PLAINS = 0;
    const BIOME_DESERT = 1;
    const BIOME_FOREST = 2;
    const BIOME_SNOW   = 3;
    const BIOME_WATER  = 4;

    let worldBiome = [];
    let worldBlocks = [];

    // ---------- BIG EMOJI POOL ----------
    const emojiPool = [
      "ğŸ›ï¸","ğŸª‘","ğŸ›‹ï¸","ğŸ’¡","ğŸª´","ğŸ“º","ğŸ“š","ğŸ’»","ğŸ§Š","ğŸ§°","ğŸ‘•","ğŸ§¶","ğŸš°","ğŸ³","ğŸ¹",
      "ğŸ½ï¸","â˜•","ğŸ·","ğŸ“¦","ğŸ§º","ğŸ§´","ğŸ§¼","ğŸ§»","ğŸª¥","ğŸš¿","ğŸ§½","ğŸ•¯ï¸","ğŸ§¸","ğŸ®","ğŸ§",
      "ğŸ“€","ğŸ“»","ğŸ“ ","ğŸ®","ğŸªŸ","ğŸšª","ğŸ§±","ğŸ²","â™Ÿï¸","ğŸ¯","ğŸ†","ğŸ¤",
      "ğŸ¼","ğŸ¨","ğŸ–¼ï¸","ğŸ§µ","ğŸª¡","ğŸ§·","ğŸ“Œ","ğŸ“","ğŸ—‚ï¸","ğŸ—„ï¸","ğŸªœ","ğŸ§¯","ğŸ§¹","ğŸª£",
      "ğŸº","â°","âŒ›","â³","ğŸ§­","ğŸ’","ğŸ”‘","ğŸ”’","ğŸ”“","ğŸ§ª","ğŸ§«","ğŸ§¬",
      "ğŸ¯","ğŸ¥«","ğŸª","ğŸ°","ğŸ“","ğŸŠ","ğŸ","ğŸ‡","ğŸŒ","ğŸ‰","ğŸ","ğŸ¥","ğŸ¥‘",
      "ğŸ•","ğŸ”","ğŸŒ­","ğŸŸ","ğŸ¥ª","ğŸŒ®","ğŸ™","ğŸ£","ğŸ¤","ğŸœ","ğŸ›","ğŸš","ğŸ¥˜","ğŸ²",
      "ğŸŒ¸","ğŸŒ¼","ğŸŒ»","ğŸŒµ","ğŸŒ´","ğŸŒ³","ğŸ‹","ğŸ","ğŸ€","ğŸ","ğŸ‚","ğŸƒ","ğŸŸ","ğŸ ","ğŸ¡",
      "ğŸ’ ","ğŸ”·","ğŸ”¶","ğŸ”º","ğŸ”»","âšª","âš«","ğŸ”˜","ğŸ”²","ğŸ”³","ğŸŸ¥","ğŸŸ§","ğŸŸ¨","ğŸŸ©","ğŸŸ¦",
      "ğŸŸª","â¬œ","â¬›","â—¼ï¸","â—»ï¸","â–«ï¸","â–ªï¸","âœ³ï¸","âœ´ï¸","â‡ï¸","â­","ğŸŒŸ","âœ¨","ğŸ’«","ğŸ”¥",
      "ğŸ””","ğŸ“˜","ğŸ“™","ğŸ“—","ğŸ“•","ğŸ“’","ğŸ““","ğŸ“”","ğŸ“š","ğŸ“","ğŸ“","âœ‚ï¸","ğŸ–Šï¸"
    ];

    // -------- BLOCK DEFINITIONS (200+ furniture + special) --------
    const BLOCKS = [
      { id: 0, key: "empty", name: "Empty", emoji: "", solid: false }
    ];

    // base world wall (outer border)
    const WALL_ID = BLOCKS.length;
    BLOCKS.push({
      id: WALL_ID,
      key: "wood_wall",
      name: "Wood Wall",
      emoji: "ğŸ§±",
      solid: true
    });

    // house walls
    const HOUSE_WALL_ID = BLOCKS.length;
    BLOCKS.push({
      id: HOUSE_WALL_ID,
      key: "house_wall",
      name: "House Wall",
      emoji: "ğŸ§±",
      solid: true
    });

    // door (walkable)
    const DOOR_ID = BLOCKS.length;
    BLOCKS.push({
      id: DOOR_ID,
      key: "door",
      name: "Door",
      emoji: "ğŸšª",
      solid: false
    });

    // portal (walkable, teleports)
    const PORTAL_ID = BLOCKS.length;
    BLOCKS.push({
      id: PORTAL_ID,
      key: "portal",
      name: "Portal",
      emoji: "ğŸŒ€",
      solid: false
    });

    // base furniture types (15 kinds)
    const furnitureBases = [
      { baseKey: "bed",       baseName: "Bed" },
      { baseKey: "table",     baseName: "Table" },
      { baseKey: "sofa",      baseName: "Sofa" },
      { baseKey: "lamp",      baseName: "Lamp" },
      { baseKey: "plant",     baseName: "Plant" },
      { baseKey: "tv",        baseName: "TV" },
      { baseKey: "bookshelf", baseName: "Bookshelf" },
      { baseKey: "pcdesk",    baseName: "PC Desk" },
      { baseKey: "fridge",    baseName: "Fridge" },
      { baseKey: "drawer",    baseName: "Drawer" },
      { baseKey: "wardrobe",  baseName: "Wardrobe" },
      { baseKey: "rug",       baseName: "Rug" },
      { baseKey: "sink",      baseName: "Sink" },
      { baseKey: "stove",     baseName: "Stove" },
      { baseKey: "piano",     baseName: "Piano" }
    ];

    const styleNames = [
      "Oak", "Birch", "Spruce", "Dark", "Light",
      "Modern", "Classic", "Compact", "Wide", "Tall",
      "Corner", "Deluxe", "Simple", "Fancy", "Industrial"
    ];

    // Generate furniture blocks with icons
    for (let i = 0; i < furnitureBases.length; i++) {
      for (let j = 0; j < styleNames.length; j++) {
        const base = furnitureBases[i];
        const style = styleNames[j];
        const id = BLOCKS.length;
        const emoji = emojiPool[id % emojiPool.length] || "â–¡";
        BLOCKS.push({
          id,
          key: `${base.baseKey}_${style.toLowerCase()}`,
          name: `${style} ${base.baseName}`,
          emoji: emoji,
          solid: false
        });
      }
    }

    function findBlockId(keyStartsWith) {
      const lower = keyStartsWith.toLowerCase();
      for (const b of BLOCKS) {
        if (b.key.startsWith(lower)) return b.id;
      }
      return WALL_ID;
    }

    // -------- PLAYER --------
    const player = {
      x: Math.floor(WORLD_W / 2),
      y: Math.floor(WORLD_H / 2),
      dirX: 0,
      dirY: -1
    };

    let selectedBlockId = WALL_ID;
    const SAVE_KEY = "minicraft_biomes_portals_houses_mobHP_fullscreen_v1";

    // -------- MOBS (with HP) --------
    const mobs = [];
    const MOB_TYPES = [
      { name: "Cow",    emoji: "ğŸ„" },
      { name: "Pig",    emoji: "ğŸ–" },
      { name: "Sheep",  emoji: "ğŸ‘" },
      { name: "Chicken",emoji: "ğŸ”" },
      { name: "Cat",    emoji: "ğŸ±" },
      { name: "Dog",    emoji: "ğŸ¶" },
      { name: "Fox",    emoji: "ğŸ¦Š" },
      { name: "Panda",  emoji: "ğŸ¼" },
      { name: "Rabbit", emoji: "ğŸ°" },
      { name: "Parrot", emoji: "ğŸ¦œ" }
    ];
    const DEFAULT_MOB_HP = 3;

    function isMobAt(x, y) {
      return mobs.some(m => m.x === x && m.y === y);
    }

    function findMobIndexAt(x, y) {
      return mobs.findIndex(m => m.x === x && m.y === y);
    }

    function addRandomMob(typeIndex) {
      let tries = 0;
      while (tries < 300) {
        const x = 2 + Math.floor(Math.random() * (WORLD_W - 4));
        const y = 2 + Math.floor(Math.random() * (WORLD_H - 4));
        if (!isWalkableBase(x, y)) { tries++; continue; }
        if (isMobAt(x, y)) { tries++; continue; }
        if (x === player.x && y === player.y) { tries++; continue; }
        mobs.push({
          x,
          y,
          typeIndex: typeIndex % MOB_TYPES.length,
          dirX: 0,
          dirY: 0,
          hp: DEFAULT_MOB_HP,
          maxHp: DEFAULT_MOB_HP
        });
        return;
      }
    }

    function initMobs() {
      mobs.length = 0;
      const mobCount = 15;
      for (let i = 0; i < mobCount; i++) {
        addRandomMob(i);
      }
    }

    function updateMobs() {
      for (const mob of mobs) {
        if (Math.random() < 0.4 || (mob.dirX === 0 && mob.dirY === 0)) {
          const dirs = [
            {dx: 1, dy: 0},
            {dx: -1, dy: 0},
            {dx: 0, dy: 1},
            {dx: 0, dy: -1},
            {dx: 0, dy: 0}
          ];
          const choice = dirs[Math.floor(Math.random() * dirs.length)];
          mob.dirX = choice.dx;
          mob.dirY = choice.dy;
        }
        if (mob.dirX === 0 && mob.dirY === 0) continue;

        const nx = mob.x + mob.dirX;
        const ny = mob.y + mob.dirY;

        if (!isWalkableBase(nx, ny)) continue;
        if (isMobAt(nx, ny)) continue;
        if (nx === player.x && ny === player.y) continue;

        mob.x = nx;
        mob.y = ny;
      }
    }

    function drawMobs() {
      for (const mob of mobs) {
        if (mob.x < cameraX || mob.x >= cameraX + VIEW_W ||
            mob.y < cameraY || mob.y >= cameraY + VIEW_H) continue;

        const px = (mob.x - cameraX) * TILE_SIZE;
        const py = (mob.y - cameraY) * TILE_SIZE;
        const mobType = MOB_TYPES[mob.typeIndex] || MOB_TYPES[0];

        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(mobType.emoji, px + TILE_SIZE / 2, py + TILE_SIZE / 2 + 2);

        const barWidth = TILE_SIZE - 8;
        const hpRatio = Math.max(0, mob.hp / mob.maxHp);
        const filled = barWidth * hpRatio;

        ctx.fillStyle = "#440000";
        ctx.fillRect(px + 4, py + 2, barWidth, 4);
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(px + 4, py + 2, filled, 4);
      }
    }

    function hitMob() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      const idx = findMobIndexAt(tx, ty);
      if (idx === -1) return;
      const mob = mobs[idx];
      mob.hp -= 1;
      if (mob.hp <= 0) {
        mobs.splice(idx, 1);
      }
    }

    // -------- PORTALS --------
    const portals = []; // {x,y,targetX,targetY}

    function createPortalPair() {
      function randomSafeCell() {
        let tries = 0;
        while (tries < 500) {
          const x = 5 + Math.floor(Math.random() * (WORLD_W - 10));
          const y = 5 + Math.floor(Math.random() * (WORLD_H - 10));
          if (!isWalkableBase(x, y)) { tries++; continue; }
          return { x, y };
        }
        return null;
      }

      const a = randomSafeCell();
      const b = randomSafeCell();
      if (!a || !b) return;

      worldBlocks[a.y][a.x] = PORTAL_ID;
      worldBlocks[b.y][b.x] = PORTAL_ID;

      portals.push({ x: a.x, y: a.y, targetX: b.x, targetY: b.y });
      portals.push({ x: b.x, y: b.y, targetX: a.x, targetY: a.y });
    }

    function findPortalAt(x, y) {
      return portals.find(p => p.x === x && p.y === y) || null;
    }

    function checkPortal() {
      const p = findPortalAt(player.x, player.y);
      if (p) {
        player.x = p.targetX;
        player.y = p.targetY;
        updateCamera();
      }
    }

    // -------- WORLD GENERATION (BIOMES + HOUSES) --------
    function generateBiomes() {
      worldBiome = [];
      for (let y = 0; y < WORLD_H; y++) {
        const row = [];
        for (let x = 0; x < WORLD_W; x++) {
          const n = Math.sin(x * 0.15) * 0.7 +
                    Math.cos(y * 0.21) * 0.7 +
                    Math.sin((x + y) * 0.07) * 0.5;
          let biome = BIOME_PLAINS;
          if (n < -0.5)      biome = BIOME_WATER;
          else if (n < -0.15) biome = BIOME_DESERT;
          else if (n < 0.3)   biome = BIOME_PLAINS;
          else if (n < 0.8)   biome = BIOME_FOREST;
          else                biome = BIOME_SNOW;
          row.push(biome);
        }
        worldBiome.push(row);
      }
    }

    function initWorldBlocks() {
      worldBlocks = [];
      for (let y = 0; y < WORLD_H; y++) {
        const row = [];
        for (let x = 0; x < WORLD_W; x++) {
          if (x === 0 || y === 0 || x === WORLD_W - 1 || y === WORLD_H - 1) {
            row.push(WALL_ID);
          } else {
            row.push(0);
          }
        }
        worldBlocks.push(row);
      }
    }

    function createHouse(topX, topY, w, h) {
      if (topX < 2 || topY < 2 ||
          topX + w >= WORLD_W - 2 ||
          topY + h >= WORLD_H - 2) return;

      for (let y = topY; y < topY + h; y++) {
        for (let x = topX; x < topX + w; x++) {
          if (worldBiome[y][x] === BIOME_WATER) return;
        }
      }

      for (let y = topY; y < topY + h; y++) {
        for (let x = topX; x < topX + w; x++) {
          const isBorder =
            x === topX || x === topX + w - 1 ||
            y === topY || y === topY + h - 1;
          if (isBorder) {
            worldBlocks[y][x] = HOUSE_WALL_ID;
          } else {
            worldBlocks[y][x] = 0;
          }
        }
      }

      const doorX = topX + Math.floor(w / 2);
      const doorY = topY + h - 1;
      worldBlocks[doorY][doorX] = DOOR_ID;

      if (w > 6) {
        const innerX = topX + Math.floor(w / 2);
        let gapY = topY + 1 + Math.floor((h - 2) / 2);
        for (let y = topY + 1; y < topY + h - 1; y++) {
          if (y === gapY) {
            worldBlocks[y][innerX] = DOOR_ID;
          } else {
            worldBlocks[y][innerX] = HOUSE_WALL_ID;
          }
        }
      } else if (h > 6) {
        const innerY = topY + Math.floor(h / 2);
        let gapX = topX + 1 + Math.floor((w - 2) / 2);
        for (let x = topX + 1; x < topX + w - 1; x++) {
          if (x === gapX) {
            worldBlocks[innerY][x] = DOOR_ID;
          } else {
            worldBlocks[innerY][x] = HOUSE_WALL_ID;
          }
        }
      }
    }

    function scatterHouses() {
      for (let gy = 10; gy < WORLD_H - 20; gy += 40) {
        for (let gx = 10; gx < WORLD_W - 20; gx += 40) {
          const b = worldBiome[gy][gx];
          if (b === BIOME_PLAINS || b === BIOME_FOREST) {
            if (Math.random() < 0.8) {
              const w = 8 + Math.floor(Math.random() * 4);
              const h = 6 + Math.floor(Math.random() * 3);
              createHouse(gx, gy, w, h);
            }
          }
        }
      }
    }

    function placeStarterFurniture() {
      outer:
      for (let y = Math.floor(WORLD_H / 2) - 10; y < WORLD_H - 2; y++) {
        for (let x = Math.floor(WORLD_W / 2) - 10; x < WORLD_W - 2; x++) {
          if (worldBiome[y][x] !== BIOME_WATER && worldBlocks[y][x] === 0) {
            player.x = x;
            player.y = y;
            break outer;
          }
        }
      }

      const hx = Math.max(2, player.x - 5);
      const hy = Math.max(2, player.y - 4);
      createHouse(hx, hy, 10, 7);

      const bedId   = findBlockId("bed");
      const tableId = findBlockId("table");
      const sofaId  = findBlockId("sofa");
      const plantId = findBlockId("plant");

      worldBlocks[hy + 5][hx + 2] = bedId;
      worldBlocks[hy + 3][hx + 4] = tableId;
      worldBlocks[hy + 3][hx + 6] = sofaId;
      worldBlocks[hy + 2][hx + 3] = plantId;
    }

    function initWorld() {
      generateBiomes();
      initWorldBlocks();
      scatterHouses();
      placeStarterFurniture();
      initMobs();

      portals.length = 0;
      for (let i = 0; i < 3; i++) {
        createPortalPair();
      }

      updateCamera();
    }

    // -------- CAMERA --------
    function updateCamera() {
      cameraX = player.x - Math.floor(VIEW_W / 2);
      cameraY = player.y - Math.floor(VIEW_H / 2);

      cameraX = Math.max(0, Math.min(cameraX, WORLD_W - VIEW_W));
      cameraY = Math.max(0, Math.min(cameraY, WORLD_H - VIEW_H));
    }

    // -------- RESIZE / FULLSCREEN HANDLING --------
    function updateViewSize() {
      VIEW_W = Math.floor(canvas.width / TILE_SIZE);
      VIEW_H = Math.floor(canvas.height / TILE_SIZE);
      if (VIEW_W < 5) VIEW_W = 5;
      if (VIEW_H < 5) VIEW_H = 5;
    }

    function resizeCanvas() {
      const uiBar = document.getElementById("uiBar");
      const touchControls = document.getElementById("touchControls");

      const topH = uiBar ? uiBar.offsetHeight : 0;
      const bottomH = touchControls ? touchControls.offsetHeight : 0;

      const availableHeight = window.innerHeight - topH - bottomH;

      canvas.width = window.innerWidth;
      canvas.height = availableHeight > 0 ? availableHeight : 200;

      updateViewSize();
      updateCamera();
    }

    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("orientationchange", () => {
      // give iOS a moment to settle toolbar size
      setTimeout(resizeCanvas, 400);
    });

    // -------- WALKABILITY --------
    function isWalkableBase(x, y) {
      if (x < 0 || y < 0 || x >= WORLD_W || y >= WORLD_H) return false;
      const tileId = worldBlocks[y][x];
      const block = BLOCKS[tileId] || BLOCKS[0];
      if (block.solid) return false;
      const biome = worldBiome[y][x];
      if (biome === BIOME_WATER) return false;
      return true;
    }

    function isWalkable(x, y) {
      if (!isWalkableBase(x, y)) return false;
      if (isMobAt(x, y)) return false;
      return true;
    }

    // -------- DRAWING --------
    function drawTile(tileId, biomeId, screenX, screenY) {
      const px = screenX * TILE_SIZE;
      const py = screenY * TILE_SIZE;

      switch (biomeId) {
        case BIOME_PLAINS:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#5da15d" : "#579957";
          break;
        case BIOME_DESERT:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#d7c374" : "#c9b86a";
          break;
        case BIOME_FOREST:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#2e7d32" : "#1b5e20";
          break;
        case BIOME_SNOW:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#e0f7fa" : "#b2ebf2";
          break;
        case BIOME_WATER:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#1e88e5" : "#1565c0";
          break;
        default:
          ctx.fillStyle = "#5da15d";
      }
      ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

      if (tileId === 0) return;
      const block = BLOCKS[tileId] || BLOCKS[0];

      if (block.id === WALL_ID || block.id === HOUSE_WALL_ID) {
        ctx.fillStyle = block.id === WALL_ID ? "#8d6e63" : "#795548";
        ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 2;
        ctx.strokeRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6);
      } else {
        ctx.fillStyle = block.id === PORTAL_ID ? "#4a148c" : "#424242";
        ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
        ctx.strokeStyle = block.id === PORTAL_ID ? "#ce93d8" : "#b0bec5";
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);

        if (block.emoji) {
          ctx.font = "18px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(block.emoji, px + TILE_SIZE / 2, py + TILE_SIZE / 2 + 1);
        }
      }
    }

    function drawPlayer() {
      const screenX = player.x - cameraX;
      const screenY = player.y - cameraY;
      if (screenX < 0 || screenX >= VIEW_W || screenY < 0 || screenY >= VIEW_H) return;

      const px = screenX * TILE_SIZE;
      const py = screenY * TILE_SIZE;

      ctx.fillStyle = "#2196f3";
      ctx.fillRect(px + 8, py + 6, TILE_SIZE - 16, TILE_SIZE - 10);

      ctx.fillStyle = "#ffcc80";
      ctx.fillRect(px + 10, py, TILE_SIZE - 20, TILE_SIZE / 2 - 2);

      ctx.fillStyle = "#000";
      ctx.fillRect(px + 13, py + 6, 2, 2);
      ctx.fillRect(px + TILE_SIZE - 15, py + 6, 2, 2);

      const cx = px + TILE_SIZE / 2;
      const cy = py + TILE_SIZE / 2;
      ctx.strokeStyle = "#ffff00";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + player.dirX * 10, cy + player.dirY * 10);
      ctx.stroke();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let sy = 0; sy < VIEW_H; sy++) {
        const wy = sy + cameraY;
        if (wy < 0 || wy >= WORLD_H) continue;
        for (let sx = 0; sx < VIEW_W; sx++) {
          const wx = sx + cameraX;
          if (wx < 0 || wx >= WORLD_W) continue;
          const tileId = worldBlocks[wy][wx];
          const biomeId = worldBiome[wy][wx];
          drawTile(tileId, biomeId, sx, sy);
        }
      }

      drawMobs();

      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      const screenFrontX = tx - cameraX;
      const screenFrontY = ty - cameraY;
      if (screenFrontX >= 0 && screenFrontX < VIEW_W &&
          screenFrontY >= 0 && screenFrontY < VIEW_H) {
        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          screenFrontX * TILE_SIZE + 2,
          screenFrontY * TILE_SIZE + 2,
          TILE_SIZE - 4,
          TILE_SIZE - 4
        );
      }

      drawPlayer();
      requestAnimationFrame(render);
    }

    // -------- MOVEMENT / ACTIONS --------
    function movePlayer(dx, dy) {
      if (dx === 0 && dy === 0) return;
      player.dirX = dx;
      player.dirY = dy;
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (isWalkable(nx, ny)) {
        player.x = nx;
        player.y = ny;
        updateCamera();
        checkPortal();
      }
    }

    function placeBlock() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return;
      if (tx === 0 || ty === 0 || tx === WORLD_W - 1 || ty === WORLD_H - 1) return;
      if (tx === player.x && ty === player.y) return;
      if (isMobAt(tx, ty)) return;
      worldBlocks[ty][tx] = selectedBlockId;
    }

    function removeBlock() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return;
      if (tx === 0 || ty === 0 || tx === WORLD_W - 1 || ty === WORLD_H - 1) return;
      worldBlocks[ty][tx] = 0;
    }

    // -------- SAVE / LOAD --------
    function saveWorld() {
      const data = {
        biome: worldBiome,
        blocks: worldBlocks,
        player: { ...player },
        mobs: mobs.map(m => ({ ...m })),
        portals: portals.map(p => ({ ...p }))
      };
      try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        alert("World saved!");
      } catch (e) {
        console.error(e);
        alert("Failed to save (localStorage error).");
      }
    }

    function loadWorld() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) {
        alert("No saved world found.");
        return;
      }
      try {
        const data = JSON.parse(raw);
        if (!Array.isArray(data.blocks) || !Array.isArray(data.biome)) {
          throw new Error("Invalid world data");
        }
        if (data.blocks.length !== WORLD_H || data.blocks[0].length !== WORLD_W) {
          throw new Error("Saved world size mismatch");
        }
        worldBlocks = data.blocks.map(row => row.slice());
        worldBiome  = data.biome.map(row => row.slice());
        if (data.player) {
          player.x = data.player.x ?? player.x;
          player.y = data.player.y ?? player.y;
          player.dirX = data.player.dirX ?? player.dirX;
          player.dirY = data.player.dirY ?? player.dirY;
        }
        mobs.length = 0;
        if (Array.isArray(data.mobs)) {
          for (const m of data.mobs) {
            mobs.push({
              x: m.x,
              y: m.y,
              typeIndex: m.typeIndex ?? 0,
              dirX: m.dirX ?? 0,
              dirY: m.dirY ?? 0,
              hp: m.hp ?? DEFAULT_MOB_HP,
              maxHp: m.maxHp ?? (m.hp ?? DEFAULT_MOB_HP)
            });
          }
        }
        portals.length = 0;
        if (Array.isArray(data.portals)) {
          for (const p of data.portals) portals.push({ ...p });
        }
        updateCamera();
        alert("World loaded!");
      } catch (e) {
        console.error(e);
        alert("Failed to load world (data corrupted?).");
      }
    }

    // -------- INVENTORY & SEARCH --------
    const inventoryList = document.getElementById("inventoryList");
    const blockSearch = document.getElementById("blockSearch");

    function createInventorySlots() {
      inventoryList.innerHTML = "";
      for (let i = 1; i < BLOCKS.length; i++) {
        const b = BLOCKS[i];
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.blockId = String(b.id);
        slot.dataset.name = b.name.toLowerCase();

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "slot-emoji";
        emojiSpan.textContent = b.emoji || "â–¡";
        const nameSpan = document.createElement("div");
        nameSpan.className = "slot-name";
        nameSpan.textContent = b.name;

        slot.appendChild(emojiSpan);
        slot.appendChild(nameSpan);

        slot.addEventListener("click", () => {
          setSelectedBlock(b.id);
        });
        slot.addEventListener("touchstart", (e) => {
          e.preventDefault();
          setSelectedBlock(b.id);
        });

        inventoryList.appendChild(slot);
      }
    }

    function setSelectedBlock(blockId) {
      selectedBlockId = blockId;
      const slots = inventoryList.querySelectorAll(".slot");
      slots.forEach(slot => {
        slot.classList.toggle(
          "selected",
          Number(slot.dataset.blockId) === blockId
        );
      });
    }

    function filterInventory() {
      const q = (blockSearch.value || "").trim().toLowerCase();
      const slots = inventoryList.querySelectorAll(".slot");
      slots.forEach(slot => {
        const name = slot.dataset.name || "";
        slot.style.display = name.includes(q) ? "inline-flex" : "none";
      });
    }

    blockSearch.addEventListener("input", filterInventory);

    // -------- INPUT: KEYBOARD --------
    window.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (["arrowup", "arrowdown", "arrowleft", "arrowright", " "].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
      switch (key) {
        case "w":
        case "arrowup":
          movePlayer(0, -1);
          break;
        case "s":
        case "arrowdown":
          movePlayer(0, 1);
          break;
        case "a":
        case "arrowleft":
          movePlayer(-1, 0);
          break;
        case "d":
        case "arrowright":
          movePlayer(1, 0);
          break;
        case " ":
          placeBlock();
          break;
        case "x":
          removeBlock();
          break;
        case "z":
          hitMob();
          break;
        case "1":
          setSelectedBlock(WALL_ID);
          break;
        case "2":
          setSelectedBlock(findBlockId("bed"));
          break;
        case "3":
          setSelectedBlock(findBlockId("table"));
          break;
        case "4":
          setSelectedBlock(findBlockId("sofa"));
          break;
      }
    });

    // -------- INPUT: MOUSE CLICK ON CANVAS --------
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      const sx = Math.floor(mx / TILE_SIZE);
      const sy = Math.floor(my / TILE_SIZE);

      const tx = sx + cameraX;
      const ty = sy + cameraY;

      const dx = tx - player.x;
      const dy = ty - player.y;
      if (dx !== 0 || dy !== 0) {
        if (Math.abs(dx) > Math.abs(dy)) {
          player.dirX = dx > 0 ? 1 : -1;
          player.dirY = 0;
        } else {
          player.dirX = 0;
          player.dirY = dy > 0 ? 1 : -1;
        }
      }

      if (e.button === 0) {
        placeBlock();
      } else if (e.button === 2) {
        removeBlock();
      }
    });

    // -------- INPUT: TOUCH BUTTONS --------
    document.querySelectorAll(".dpad-btn").forEach(btn => {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const [dx, dy] = btn.dataset.move.split(",").map(Number);
        movePlayer(dx, dy);
      });
    });

    document.querySelectorAll(".touch-action-btn").forEach(btn => {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const action = btn.dataset.action;
        if (action === "place") placeBlock();
        if (action === "remove") removeBlock();
        if (action === "hit") hitMob();
      });
    });

    // -------- SAVE/LOAD BUTTONS --------
    document.getElementById("saveBtn").addEventListener("click", saveWorld);
    document.getElementById("loadBtn").addEventListener("click", loadWorld);
    document.getElementById("saveBtn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      saveWorld();
    });
    document.getElementById("loadBtn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      loadWorld();
    });

    // -------- INIT --------
    createInventorySlots();
    setSelectedBlock(WALL_ID);
    filterInventory();
    resizeCanvas();   // set canvas size & VIEW_W/H before generating world
    initWorld();
    render();
    setInterval(updateMobs, 300);
  </script>
</body>
</html>
