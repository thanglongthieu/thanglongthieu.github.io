<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MiniCraft â€“ Huge Mobs, Regen, Combat FX</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    #gameContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    canvas#gameCanvas {
      background: #66bb6a;
      image-rendering: pixelated;
      border: 2px solid #444;
      touch-action: none;
      display: block;
      width: 100vw;
    }

    /* TOP inventory + search + save/load (COMPACT) */
    #uiBar {
      background: #222;
      padding: 2px 6px;
      font-size: 11px;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1.2fr) auto;
      gap: 6px;
      align-items: center;
      border-top: 1px solid #333;
      box-sizing: border-box;
    }

    #inventoryPanel {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    #inventoryHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      font-size: 10px;
    }

    #blockSearch {
      flex: 1;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #eee;
      font-size: 10px;
    }

    #inventoryList {
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
      max-height: 48px;
      overflow-y: auto;
      padding-right: 2px;
    }

    .slot {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border-radius: 4px;
      border: 1px solid #555;
      box-sizing: border-box;
      background: #333;
      cursor: pointer;
      user-select: none;
      font-size: 16px;
    }
    .slot span.slot-emoji {
      pointer-events: none;
    }
    .slot.selected {
      border-color: #ffeb3b;
      box-shadow: 0 0 6px #ffeb3b;
    }
    .slot-name {
      font-size: 8px;
      color: #ccc;
      text-align: center;
      pointer-events: none;
      line-height: 1.1;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #help {
      font-size: 10px;
      color: #ccc;
      align-self: center;
      line-height: 1.3;
    }

    #saveLoadButtons {
      display: flex;
      flex-direction: column;
      gap: 3px;
      align-items: flex-end;
      justify-content: center;
    }

    button {
      background: #424242;
      border: 1px solid #666;
      border-radius: 4px;
      color: #eee;
      padding: 3px 6px;
      font-size: 10px;
      cursor: pointer;
      white-space: nowrap;
    }
    button:active {
      background: #616161;
    }

    /* Touch controls (bottom) */
    #touchControls {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2px 0 4px;
      gap: 8px;
      background: #181818;
      border-top: 1px solid #333;
      box-sizing: border-box;
    }
    #dpad {
      display: grid;
      grid-template-columns: 32px 32px 32px;
      grid-template-rows: 32px 32px 32px;
      gap: 3px;
    }
    .dpad-btn {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #303030;
      border-radius: 4px;
      border: 1px solid #555;
      font-size: 16px;
      user-select: none;
    }
    .dpad-btn:active {
      background: #505050;
    }
    .dpad-empty {
      background: transparent;
      border: none;
    }
    #touchActions {
      display: flex;
      flex-wrap: wrap;
      flex-direction: row;
      gap: 4px;
      max-width: 220px;
      justify-content: center;
    }
    .touch-action-btn {
      min-width: 60px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      background: #37474f;
      border: 1px solid #607d8b;
      font-size: 10px;
      user-select: none;
      padding: 0 4px;
    }
    .touch-action-btn:active {
      background: #546e7a;
    }

    @media (min-width: 768px) {
      #touchControls {
        display: none;
      }
    }

    @media (max-width: 600px) {
      #uiBar {
        grid-template-columns: minmax(0, 1.7fr) minmax(0, 1.3fr);
        grid-template-rows: auto auto;
      }
      #saveLoadButtons {
        flex-direction: row;
        justify-content: flex-start;
      }
      #help {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
  </div>

  <!-- Mobile / touch controls -->
  <div id="touchControls">
    <div id="dpad">
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="0,-1">â–²</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="-1,0">â—€</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="1,0">â–¶</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="0,1">â–¼</div>
      <div class="dpad-empty"></div>
    </div>
    <div id="touchActions">
      <div class="touch-action-btn" data-action="place">Place</div>
      <div class="touch-action-btn" data-action="remove">Remove</div>
      <div class="touch-action-btn" data-action="hit">Hit</div>
      <div class="touch-action-btn" data-action="zoomIn">Zoom +</div>
      <div class="touch-action-btn" data-action="zoomOut">Zoom âˆ’</div>
    </div>
  </div>

  <!-- Inventory + search + save/load -->
  <div id="uiBar">
    <div id="inventoryPanel">
      <div id="inventoryHeader">
        <span>Furniture</span>
        <input id="blockSearch" type="text" placeholder="Search..." />
      </div>
      <div id="inventoryList"></div>
    </div>
    <div id="help">
      PC: WASD/Arrows, Space=Place, X=Remove, Z=Hit, +/= Zoom In, âˆ’ Zoom Out  
      Mobile: D-pad + Place / Remove / Hit / Zoom
    </div>
    <div id="saveLoadButtons">
      <button id="saveBtn">ğŸ’¾ Save</button>
      <button id="loadBtn">ğŸ“‚ Load</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- SIMPLE SFX (replace with your own paths if needed) ---
    const sfxPlayerHit = new Audio("player_hit.mp3"); // when YOU get hit
    const sfxMobHit    = new Audio("mob_hit.mp3");    // when MOB gets hit

    function playSound(audio) {
      if (!audio) return;
      try {
        audio.currentTime = 0;
        audio.play();
      } catch (e) {
        // ignore autoplay errors
      }
    }

    // --- HIT ANIMATION EFFECTS ---
    // Each effect: { type: 'mob'|'player', x, y, size, ttl }
    let hitEffects = [];
    const HIT_DURATION = 200; // ms

    function spawnMobHitEffect(mob) {
      const s = mobSize(mob);
      hitEffects.push({
        type: "mob",
        x: mob.x,
        y: mob.y,
        size: s,
        ttl: HIT_DURATION
      });
    }

    function spawnPlayerHitEffect() {
      hitEffects.push({
        type: "player",
        ttl: HIT_DURATION
      });
    }

    function updateHitEffects(dt) {
      hitEffects = hitEffects.map(fx => ({ ...fx, ttl: fx.ttl - dt }))
                             .filter(fx => fx.ttl > 0);
    }

    function drawHitEffects() {
      for (const fx of hitEffects) {
        const alpha = Math.max(0, fx.ttl / HIT_DURATION);

        if (fx.type === "mob") {
          const s = fx.size;
          const sx = fx.x - cameraX;
          const sy = fx.y - cameraY;
          if (sx + s <= 0 || sy + s <= 0 || sx >= VIEW_W || sy >= VIEW_H) continue;

          const px = sx * TILE_SIZE;
          const py = sy * TILE_SIZE;
          const w  = s * TILE_SIZE;
          const h  = s * TILE_SIZE;

          ctx.fillStyle = `rgba(255,0,0,${0.35 * alpha})`;
          ctx.fillRect(px, py, w, h);
        } else if (fx.type === "player") {
          const sx = player.x - cameraX;
          const sy = player.y - cameraY;
          if (sx < 0 || sy < 0 || sx >= VIEW_W || sy >= VIEW_H) continue;

          const px = sx * TILE_SIZE;
          const py = sy * TILE_SIZE;

          ctx.strokeStyle = `rgba(255,255,0,${alpha})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.rect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
          ctx.stroke();
        }
      }
    }

    // ZOOM
    let TILE_SIZE = 32;
    const MIN_TILE_SIZE = 16;
    const MAX_TILE_SIZE = 64;

    let VIEW_W = 25;
    let VIEW_H = 15;

    // World
    const WORLD_W = 200;
    const WORLD_H = 200;
    let cameraX = 0;
    let cameraY = 0;

    // Biomes
    const BIOME_PLAINS = 0;
    const BIOME_DESERT = 1;
    const BIOME_FOREST = 2;
    const BIOME_SNOW   = 3;
    const BIOME_WATER  = 4;

    let worldBiome = [];
    let worldBlocks = [];

    // Emoji pool for furniture
    const emojiPool = [
      "ğŸ›ï¸","ğŸª‘","ğŸ›‹ï¸","ğŸ’¡","ğŸª´","ğŸ“º","ğŸ“š","ğŸ’»","ğŸ§Š","ğŸ§°","ğŸ‘•","ğŸ§¶","ğŸš°","ğŸ³","ğŸ¹",
      "ğŸ½ï¸","â˜•","ğŸ·","ğŸ“¦","ğŸ§º","ğŸ§´","ğŸ§¼","ğŸ§»","ğŸª¥","ğŸš¿","ğŸ§½","ğŸ•¯ï¸","ğŸ§¸","ğŸ®","ğŸ§",
      "ğŸ“€","ğŸ“»","ğŸ“ ","ğŸ®","ğŸªŸ","ğŸšª","ğŸ§±","ğŸ²","â™Ÿï¸","ğŸ¯","ğŸ†","ğŸ¤",
      "ğŸ¼","ğŸ¨","ğŸ–¼ï¸","ğŸ§µ","ğŸª¡","ğŸ§·","ğŸ“Œ","ğŸ“","ğŸ—‚ï¸","ğŸ—„ï¸","ğŸªœ","ğŸ§¯","ğŸ§¹","ğŸª£",
      "ğŸº","â°","âŒ›","â³","ğŸ§­","ğŸ’","ğŸ”‘","ğŸ”’","ğŸ”“","ğŸ§ª","ğŸ§«","ğŸ§¬",
      "ğŸ¯","ğŸ¥«","ğŸª","ğŸ°","ğŸ“","ğŸŠ","ğŸ","ğŸ‡","ğŸŒ","ğŸ‰","ğŸ","ğŸ¥","ğŸ¥‘",
      "ğŸ•","ğŸ”","ğŸŒ­","ğŸŸ","ğŸ¥ª","ğŸŒ®","ğŸ™","ğŸ£","ğŸ¤","ğŸœ","ğŸ›","ğŸš","ğŸ¥˜","ğŸ²",
      "ğŸŒ¸","ğŸŒ¼","ğŸŒ»","ğŸŒµ","ğŸŒ´","ğŸŒ³","ğŸ‹","ğŸ","ğŸ€","ğŸ","ğŸ‚","ğŸƒ","ğŸŸ","ğŸ ","ğŸ¡",
      "ğŸ’ ","ğŸ”·","ğŸ”¶","ğŸ”º","ğŸ”»","âšª","âš«","ğŸ”˜","ğŸ”²","ğŸ”³","ğŸŸ¥","ğŸŸ§","ğŸŸ¨","ğŸŸ©","ğŸŸ¦",
      "ğŸŸª","â¬œ","â¬›","â—¼ï¸","â—»ï¸","â–«ï¸","â–ªï¸","âœ³ï¸","âœ´ï¸","â‡ï¸","â­","ğŸŒŸ","âœ¨","ğŸ’«","ğŸ”¥",
      "ğŸ””","ğŸ“˜","ğŸ“™","ğŸ“—","ğŸ“•","ğŸ“’","ğŸ““","ğŸ“”","ğŸ“š","ğŸ“","ğŸ“","âœ‚ï¸","ğŸ–Šï¸"
    ];

    // Blocks
    const BLOCKS = [
      { id: 0, key: "empty", name: "Empty", emoji: "", solid: false }
    ];

    const WALL_ID = BLOCKS.length;
    BLOCKS.push({
      id: WALL_ID,
      key: "wood_wall",
      name: "Wood Wall",
      emoji: "ğŸ§±",
      solid: true
    });

    const HOUSE_WALL_ID = BLOCKS.length;
    BLOCKS.push({
      id: HOUSE_WALL_ID,
      key: "house_wall",
      name: "House Wall",
      emoji: "ğŸ§±",
      solid: true
    });

    const DOOR_ID = BLOCKS.length;
    BLOCKS.push({
      id: DOOR_ID,
      key: "door",
      name: "Door",
      emoji: "ğŸšª",
      solid: false
    });

    const PORTAL_ID = BLOCKS.length;
    BLOCKS.push({
      id: PORTAL_ID,
      key: "portal",
      name: "Portal",
      emoji: "ğŸŒ€",
      solid: false
    });

    const furnitureBases = [
      { baseKey: "bed",       baseName: "Bed" },
      { baseKey: "table",     baseName: "Table" },
      { baseKey: "sofa",      baseName: "Sofa" },
      { baseKey: "lamp",      baseName: "Lamp" },
      { baseKey: "plant",     baseName: "Plant" },
      { baseKey: "tv",        baseName: "TV" },
      { baseKey: "bookshelf", baseName: "Bookshelf" },
      { baseKey: "pcdesk",    baseName: "PC Desk" },
      { baseKey: "fridge",    baseName: "Fridge" },
      { baseKey: "drawer",    baseName: "Drawer" },
      { baseKey: "wardrobe",  baseName: "Wardrobe" },
      { baseKey: "rug",       baseName: "Rug" },
      { baseKey: "sink",      baseName: "Sink" },
      { baseKey: "stove",     baseName: "Stove" },
      { baseKey: "piano",     baseName: "Piano" }
    ];

    const styleNames = [
      "Oak", "Birch", "Spruce", "Dark", "Light",
      "Modern", "Classic", "Compact", "Wide", "Tall",
      "Corner", "Deluxe", "Simple", "Fancy", "Industrial"
    ];

    for (let i = 0; i < furnitureBases.length; i++) {
      for (let j = 0; j < styleNames.length; j++) {
        const base = furnitureBases[i];
        const style = styleNames[j];
        const id = BLOCKS.length;
        const emoji = emojiPool[id % emojiPool.length] || "â–¡";
        BLOCKS.push({
          id,
          key: `${base.baseKey}_${style.toLowerCase()}`,
          name: `${style} ${base.baseName}`,
          emoji: emoji,
          solid: false
        });
      }
    }

    function findBlockId(keyStartsWith) {
      const lower = keyStartsWith.toLowerCase();
      for (const b of BLOCKS) {
        if (b.key.startsWith(lower)) return b.id;
      }
      return WALL_ID;
    }

    // Player with HP
    const PLAYER_MAX_HP = 999;

    const player = {
      x: Math.floor(WORLD_W / 2),
      y: Math.floor(WORLD_H / 2),
      dirX: 0,
      dirY: -1,
      hp: PLAYER_MAX_HP,
      maxHp: PLAYER_MAX_HP
    };

    let selectedBlockId = WALL_ID;
    const SAVE_KEY = "minicraft_huge_mobs_hp_ai_fx_regen_v1";

    // Mobs
    const mobs = [];

    const MOB_TYPES = [
      // Small passive mobs (1Ã—1)
      { name: "Cow",        emoji: "ğŸ„", size: 1 },
      { name: "Pig",        emoji: "ğŸ–", size: 1 },
      { name: "Sheep",      emoji: "ğŸ‘", size: 1 },
      { name: "Chicken",    emoji: "ğŸ”", size: 1 },
      { name: "Cat",        emoji: "ğŸ±", size: 1 },
      { name: "Dog",        emoji: "ğŸ¶", size: 1 },
      { name: "Fox",        emoji: "ğŸ¦Š", size: 1 },
      { name: "Panda",      emoji: "ğŸ¼", size: 1 },
      { name: "Rabbit",     emoji: "ğŸ°", size: 1 },
      { name: "Parrot",     emoji: "ğŸ¦œ", size: 1 },

      // 2Ã—2 mini bosses
      { name: "Giant Golem",  emoji: "ğŸª¨", size: 2 },
      { name: "Big Slime",    emoji: "ğŸ§«", size: 2 },

      // 3Ã—3 bosses
      { name: "Titan Golem",   emoji: "ğŸª¨", size: 3 },
      { name: "Mega Slime",    emoji: "ğŸŸ¢", size: 3 },
      { name: "Lava Colossus", emoji: "ğŸŒ‹", size: 3 },

      // 4Ã—4 bosses
      { name: "Forest Guardian", emoji: "ğŸŒ²", size: 4 },
      { name: "Ice Guardian",    emoji: "â„ï¸", size: 4 },

      // 5Ã—5 huge bosses
      { name: "Ancient Dragon", emoji: "ğŸ‰", size: 5 },
      { name: "Sky Serpent",    emoji: "ğŸ²", size: 5 },

      // 10Ã—10 ultra boss
      { name: "World Eater",    emoji: "ğŸŒŒğŸ’€", size: 10 }
    ];

    const BASE_HP = 3; // HP per tile

    function defaultHpForSize(s) {
      return BASE_HP * s * s;
    }

    function mobSize(mob) {
      const t = MOB_TYPES[mob.typeIndex] || MOB_TYPES[0];
      return t.size || 1;
    }

    function mobTypeSize(typeIndex) {
      const t = MOB_TYPES[typeIndex] || MOB_TYPES[0];
      return t.size || 1;
    }

    function isMobAt(x, y) {
      return mobs.some(m => {
        const s = mobSize(m);
        return x >= m.x && x < m.x + s && y >= m.y && y < m.y + s;
      });
    }

    function findMobIndexAt(x, y) {
      for (let i = 0; i < mobs.length; i++) {
        const m = mobs[i];
        const s = mobSize(m);
        if (x >= m.x && x < m.x + s && y >= m.y && y < m.y + s) {
          return i;
        }
      }
      return -1;
    }

    function canMobOccupy(typeIndex, x, y, ignoreMob = null) {
      const s = mobTypeSize(typeIndex);
      for (let dy = 0; dy < s; dy++) {
        for (let dx = 0; dx < s; dx++) {
          const tx = x + dx;
          const ty = y + dy;
          if (!isWalkableBase(tx, ty)) return false;
          if (tx === player.x && ty === player.y) return false;

          for (const other of mobs) {
            if (other === ignoreMob) continue;
            const os = mobSize(other);
            if (tx >= other.x && tx < other.x + os &&
                ty >= other.y && ty < other.y + os) {
              return false;
            }
          }
        }
      }
      return true;
    }

    function addRandomMob(typeIndex) {
      const s = mobTypeSize(typeIndex);
      let tries = 0;
      while (tries < 600) {
        const x = 2 + Math.floor(Math.random() * (WORLD_W - 2 - s));
        const y = 2 + Math.floor(Math.random() * (WORLD_H - 2 - s));
        if (!canMobOccupy(typeIndex, x, y, null)) {
          tries++;
          continue;
        }
        const t = MOB_TYPES[typeIndex] || MOB_TYPES[0];
        const maxHp = defaultHpForSize(t.size || 1);
        mobs.push({
          x,
          y,
          typeIndex,
          dirX: 0,
          dirY: 0,
          hp: maxHp,
          maxHp: maxHp,
          mode: "idle",       // idle | aggro | flee
          regenTimerMs: 0     // individual regen timer
        });
        return;
      }
    }

    function initMobs() {
      mobs.length = 0;
      const mobCount = 50;

      // Guarantee at least one of each type
      for (let i = 0; i < MOB_TYPES.length && i < mobCount; i++) {
        addRandomMob(i);
      }
      // Fill remaining random
      for (let i = MOB_TYPES.length; i < mobCount; i++) {
        const typeIndex = Math.floor(Math.random() * MOB_TYPES.length);
        addRandomMob(typeIndex);
      }
    }

    function mobAdjacentToPlayer(mob) {
      const s = mobSize(mob);
      for (let dy = 0; dy < s; dy++) {
        for (let dx = 0; dx < s; dx++) {
          const tx = mob.x + dx;
          const ty = mob.y + dy;
          const dist = Math.abs(tx - player.x) + Math.abs(ty - player.y);
          if (dist === 1) return true;
        }
      }
      return false;
    }

    function distancePlayerToMob(mob) {
      const s = mobSize(mob);
      let best = Infinity;
      for (let dy = 0; dy < s; dy++) {
        for (let dx = 0; dx < s; dx++) {
          const tx = mob.x + dx;
          const ty = mob.y + dy;
          const dist = Math.abs(tx - player.x) + Math.abs(ty - player.y);
          if (dist < best) best = dist;
        }
      }
      return best;
    }

    function anyMobWithinRadius(radius) {
      for (const mob of mobs) {
        if (distancePlayerToMob(mob) <= radius) return true;
      }
      return false;
    }

    let lastTime = performance.now();

    // --- HP REGEN (PLAYER) ---
    let regenTimerMs = 0;
    const REGEN_RADIUS = 4;          // how far you must run away
    const REGEN_INTERVAL_MS = 500;   // 1 HP per 0.5s when safe

    // --- MOB REGEN (BIGGER = SLOWER) ---
    const MOB_BASE_REGEN_INTERVAL_MS = 1500; // base: 1Ã—1 mob = 1 HP / 1.5s

    // --- COMBAT BORDER ---
    const COMBAT_RADIUS = 4;         // when any mob is this close, show red border

    function attackPlayer(mob) {
      const s = mobSize(mob);
      const dmg = Math.max(1, Math.floor(s / 2)); // 1 for small, up to 5 for 10Ã—10
      player.hp -= dmg;
      if (player.hp < 0) player.hp = 0;

      spawnPlayerHitEffect();
      playSound(sfxPlayerHit);

      // getting hit resets regen buildup
      regenTimerMs = 0;

      if (player.hp === 0) {
        alert("You were defeated! Respawning with full HP.");
        player.hp = player.maxHp;
        player.x = Math.floor(WORLD_W / 2);
        player.y = Math.floor(WORLD_H / 2);
        updateCamera();
      }
    }

    function updateMobRegen(dt) {
      for (const mob of mobs) {
        if (mob.hp >= mob.maxHp) {
          mob.regenTimerMs = 0;
          continue;
        }

        // If player is too close, no regen
        const dist = distancePlayerToMob(mob);
        if (dist <= REGEN_RADIUS + 1) {
          mob.regenTimerMs = 0;
          continue;
        }

        const size = mobSize(mob);
        const interval = MOB_BASE_REGEN_INTERVAL_MS * size; // bigger = slower

        mob.regenTimerMs += dt;

        while (mob.regenTimerMs >= interval && mob.hp < mob.maxHp) {
          mob.hp += 1; // heal 1 HP
          mob.regenTimerMs -= interval;
        }
      }
    }

    function updateMobs() {
      for (const mob of mobs) {
        const s = mobSize(mob);

        if (mob.mode === "idle") {
          if (Math.random() < 0.4 || (mob.dirX === 0 && mob.dirY === 0)) {
            const dirs = [
              {dx: 1, dy: 0},
              {dx: -1, dy: 0},
              {dx: 0, dy: 1},
              {dx: 0, dy: -1},
              {dx: 0, dy: 0}
            ];
            const choice = dirs[Math.floor(Math.random() * dirs.length)];
            mob.dirX = choice.dx;
            mob.dirY = choice.dy;
          }
        } else if (mob.mode === "aggro") {
          const dx = player.x - (mob.x + s / 2);
          const dy = player.y - (mob.y + s / 2);
          if (Math.abs(dx) > Math.abs(dy)) {
            mob.dirX = dx > 0 ? 1 : -1;
            mob.dirY = 0;
          } else {
            mob.dirX = 0;
            mob.dirY = dy > 0 ? 1 : -1;
          }
          if (Math.random() < 0.15) {
            mob.dirX = 0;
            mob.dirY = 0;
          }
        } else if (mob.mode === "flee") {
          const dx = player.x - (mob.x + s / 2);
          const dy = player.y - (mob.y + s / 2);
          if (Math.abs(dx) > Math.abs(dy)) {
            mob.dirX = dx > 0 ? -1 : 1;
            mob.dirY = 0;
          } else {
            mob.dirX = 0;
            mob.dirY = dy > 0 ? -1 : 1;
          }
          if (Math.random() < 0.2) {
            mob.dirX = 0;
            mob.dirY = 0;
          }
        }

        if (mob.dirX === 0 && mob.dirY === 0) continue;

        const nx = mob.x + mob.dirX;
        const ny = mob.y + mob.dirY;

        if (!canMobOccupy(mob.typeIndex, nx, ny, mob)) continue;

        mob.x = nx;
        mob.y = ny;

        if (mobAdjacentToPlayer(mob) && Math.random() < 0.35) {
          attackPlayer(mob);
        }
      }
    }

    function drawMobs() {
      for (const mob of mobs) {
        const s = mobSize(mob);

        if (mob.x + s <= cameraX || mob.x >= cameraX + VIEW_W ||
            mob.y + s <= cameraY || mob.y >= cameraY + VIEW_H) {
          continue;
        }

        const mobType = MOB_TYPES[mob.typeIndex] || MOB_TYPES[0];

        const screenX = (mob.x - cameraX) * TILE_SIZE;
        const screenY = (mob.y - cameraY) * TILE_SIZE;
        const width   = s * TILE_SIZE;
        const height  = s * TILE_SIZE;

        // Name bar for big mobs
        if (s >= 3) {
          const nameText = mobType.name;
          const nameFontSize = Math.max(10, Math.floor(TILE_SIZE * 0.35));
          ctx.font = nameFontSize + "px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";

          const nameX = screenX + width / 2;
          const nameY = screenY - 2;

          const paddingX = 6;
          const paddingY = 2;
          const approxTextWidth = ctx.measureText(nameText).width;
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(
            nameX - approxTextWidth / 2 - paddingX,
            nameY - nameFontSize - paddingY,
            approxTextWidth + paddingX * 2,
            nameFontSize + paddingY * 2
          );

          ctx.fillStyle = "#ffffff";
          ctx.fillText(nameText, nameX, nameY);
        }

        const fontScale =
          s === 1 ? 0.7 :
          s === 2 ? 1.0 :
          s <= 4 ? 1.2 :
          1.4;
        ctx.font = Math.floor(TILE_SIZE * fontScale) + "px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const cx = screenX + width / 2;
        const cy = screenY + height / 2;
        ctx.fillText(mobType.emoji, cx, cy + 2);

        const barWidth = width - 8;
        const hpRatio = Math.max(0, mob.hp / mob.maxHp);
        const filled = barWidth * hpRatio;

        ctx.fillStyle = "#440000";
        ctx.fillRect(screenX + 4, screenY + 2, barWidth, 4);
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(screenX + 4, screenY + 2, filled, 4);
      }
    }

    function hitMob() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      const idx = findMobIndexAt(tx, ty);
      if (idx === -1) return;
      const mob = mobs[idx];

      spawnMobHitEffect(mob);
      playSound(sfxMobHit);

      mob.hp -= 1;
      if (mob.hp <= 0) {
        mobs.splice(idx, 1);
        return;
      }

      if (Math.random() < 0.5) {
        mob.mode = "aggro";
        if (mobAdjacentToPlayer(mob) && Math.random() < 0.5) {
          attackPlayer(mob);
        }
      } else {
        mob.mode = "flee";
      }
    }

    // Portals
    const portals = [];

    function createPortalPair() {
      function randomSafeCell() {
        let tries = 0;
        while (tries < 500) {
          const x = 5 + Math.floor(Math.random() * (WORLD_W - 10));
          const y = 5 + Math.floor(Math.random() * (WORLD_H - 10));
          if (!isWalkableBase(x, y)) { tries++; continue; }
          return { x, y };
        }
        return null;
      }

      const a = randomSafeCell();
      const b = randomSafeCell();
      if (!a || !b) return;

      worldBlocks[a.y][a.x] = PORTAL_ID;
      worldBlocks[b.y][b.x] = PORTAL_ID;

      portals.push({ x: a.x, y: a.y, targetX: b.x, targetY: b.y });
      portals.push({ x: b.x, y: b.y, targetX: a.x, targetY: a.y });
    }

    function findPortalAt(x, y) {
      return portals.find(p => p.x === x && p.y === y) || null;
    }

    function checkPortal() {
      const p = findPortalAt(player.x, player.y);
      if (p) {
        player.x = p.targetX;
        player.y = p.targetY;
        updateCamera();
      }
    }

    // World generation
    function generateBiomes() {
      worldBiome = [];
      for (let y = 0; y < WORLD_H; y++) {
        const row = [];
        for (let x = 0; x < WORLD_W; x++) {
          const n = Math.sin(x * 0.15) * 0.7 +
                    Math.cos(y * 0.21) * 0.7 +
                    Math.sin((x + y) * 0.07) * 0.5;
          let biome = BIOME_PLAINS;
          if (n < -0.5)      biome = BIOME_WATER;
          else if (n < -0.15) biome = BIOME_DESERT;
          else if (n < 0.3)   biome = BIOME_PLAINS;
          else if (n < 0.8)   biome = BIOME_FOREST;
          else                biome = BIOME_SNOW;
          row.push(biome);
        }
        worldBiome.push(row);
      }
    }

    function initWorldBlocks() {
      worldBlocks = [];
      for (let y = 0; y < WORLD_H; y++) {
        const row = [];
        for (let x = 0; x < WORLD_W; x++) {
          if (x === 0 || y === 0 || x === WORLD_W - 1 || y === WORLD_H - 1) {
            row.push(WALL_ID);
          } else {
            row.push(0);
          }
        }
        worldBlocks.push(row);
      }
    }

    function createHouse(topX, topY, w, h) {
      if (topX < 2 || topY < 2 ||
          topX + w >= WORLD_W - 2 ||
          topY + h >= WORLD_H - 2) return;

      for (let y = topY; y < topY + h; y++) {
        for (let x = topX; x < topX + w; x++) {
          if (worldBiome[y][x] === BIOME_WATER) return;
        }
      }

      for (let y = topY; y < topY + h; y++) {
        for (let x = topX; x < topX + w; x++) {
          const isBorder =
            x === topX || x === topX + w - 1 ||
            y === topY || y === topY + h - 1;
          if (isBorder) {
            worldBlocks[y][x] = HOUSE_WALL_ID;
          } else {
            worldBlocks[y][x] = 0;
          }
        }
      }

      const doorX = topX + Math.floor(w / 2);
      const doorY = topY + h - 1;
      worldBlocks[doorY][doorX] = DOOR_ID;

      if (w > 6) {
        const innerX = topX + Math.floor(w / 2);
        let gapY = topY + 1 + Math.floor((h - 2) / 2);
        for (let y = topY + 1; y < topY + h - 1; y++) {
          if (y === gapY) worldBlocks[y][innerX] = DOOR_ID;
          else            worldBlocks[y][innerX] = HOUSE_WALL_ID;
        }
      } else if (h > 6) {
        const innerY = topY + Math.floor(h / 2);
        let gapX = topX + 1 + Math.floor((w - 2) / 2);
        for (let x = topX + 1; x < topX + w - 1; x++) {
          if (x === gapX) worldBlocks[innerY][x] = DOOR_ID;
          else            worldBlocks[innerY][x] = HOUSE_WALL_ID;
        }
      }
    }

    function scatterHouses() {
      for (let gy = 10; gy < WORLD_H - 20; gy += 40) {
        for (let gx = 10; gx < WORLD_W - 20; gx += 40) {
          const b = worldBiome[gy][gx];
          if (b === BIOME_PLAINS || b === BIOME_FOREST) {
            if (Math.random() < 0.8) {
              const w = 8 + Math.floor(Math.random() * 4);
              const h = 6 + Math.floor(Math.random() * 3);
              createHouse(gx, gy, w, h);
            }
          }
        }
      }
    }

    function placeStarterFurniture() {
      outer:
      for (let y = Math.floor(WORLD_H / 2) - 10; y < WORLD_H - 2; y++) {
        for (let x = Math.floor(WORLD_W / 2) - 10; x < WORLD_W - 2; x++) {
          if (worldBiome[y][x] !== BIOME_WATER && worldBlocks[y][x] === 0) {
            player.x = x;
            player.y = y;
            break outer;
          }
        }
      }

      const hx = Math.max(2, player.x - 5);
      const hy = Math.max(2, player.y - 4);
      createHouse(hx, hy, 10, 7);

      const bedId   = findBlockId("bed");
      const tableId = findBlockId("table");
      const sofaId  = findBlockId("sofa");
      const plantId = findBlockId("plant");

      worldBlocks[hy + 5][hx + 2] = bedId;
      worldBlocks[hy + 3][hx + 4] = tableId;
      worldBlocks[hy + 3][hx + 6] = sofaId;
      worldBlocks[hy + 2][hx + 3] = plantId;
    }

    function initWorld() {
      generateBiomes();
      initWorldBlocks();
      scatterHouses();
      placeStarterFurniture();
      initMobs();

      portals.length = 0;
      for (let i = 0; i < 3; i++) {
        createPortalPair();
      }

      updateCamera();
    }

    // Camera & resize
    function updateCamera() {
      cameraX = player.x - Math.floor(VIEW_W / 2);
      cameraY = player.y - Math.floor(VIEW_H / 2);

      cameraX = Math.max(0, Math.min(cameraX, WORLD_W - VIEW_W));
      cameraY = Math.max(0, Math.min(cameraY, WORLD_H - VIEW_H));
    }

    function updateViewSize() {
      VIEW_W = Math.floor(canvas.width / TILE_SIZE);
      VIEW_H = Math.floor(canvas.height / TILE_SIZE);
      if (VIEW_W < 5) VIEW_W = 5;
      if (VIEW_H < 5) VIEW_H = 5;
    }

    function resizeCanvas() {
      const uiBar = document.getElementById("uiBar");
      const touchControls = document.getElementById("touchControls");

      const topH = uiBar ? uiBar.offsetHeight : 0;
      const bottomH =
        touchControls && getComputedStyle(touchControls).display !== "none"
          ? touchControls.offsetHeight
          : 0;

      const availableHeight = window.innerHeight - topH - bottomH;

      canvas.width = window.innerWidth;
      canvas.height = availableHeight > 0 ? availableHeight : 200;

      updateViewSize();
      updateCamera();
    }

    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("orientationchange", () => {
      setTimeout(resizeCanvas, 400);
    });

    // Zoom
    function changeZoom(direction) {
      const oldSize = TILE_SIZE;
      if (direction > 0) {
        TILE_SIZE = Math.min(MAX_TILE_SIZE, TILE_SIZE + 8);
      } else {
        TILE_SIZE = Math.max(MIN_TILE_SIZE, TILE_SIZE - 8);
      }
      if (TILE_SIZE === oldSize) return;
      updateViewSize();
      updateCamera();
    }

    // Walkable
    function isWalkableBase(x, y) {
      if (x < 0 || y < 0 || x >= WORLD_W || y >= WORLD_H) return false;
      const tileId = worldBlocks[y][x];
      const block = BLOCKS[tileId] || BLOCKS[0];
      if (block.solid) return false;
      const biome = worldBiome[y][x];
      if (biome === BIOME_WATER) return false;
      return true;
    }

    function isWalkable(x, y) {
      if (!isWalkableBase(x, y)) return false;
      if (isMobAt(x, y)) return false;
      return true;
    }

    // Tiles & player drawing
    function drawTile(tileId, biomeId, screenX, screenY) {
      const px = screenX * TILE_SIZE;
      const py = screenY * TILE_SIZE;

      switch (biomeId) {
        case BIOME_PLAINS:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#5da15d" : "#579957";
          break;
        case BIOME_DESERT:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#d7c374" : "#c9b86a";
          break;
        case BIOME_FOREST:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#2e7d32" : "#1b5e20";
          break;
        case BIOME_SNOW:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#e0f7fa" : "#b2ebf2";
          break;
        case BIOME_WATER:
          ctx.fillStyle = (screenX + screenY) % 2 === 0 ? "#1e88e5" : "#1565c0";
          break;
        default:
          ctx.fillStyle = "#5da15d";
      }
      ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

      if (tileId === 0) return;
      const block = BLOCKS[tileId] || BLOCKS[0];

      if (block.id === WALL_ID || block.id === HOUSE_WALL_ID) {
        ctx.fillStyle = block.id === WALL_ID ? "#8d6e63" : "#795548";
        ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 2;
        ctx.strokeRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6);
      } else {
        ctx.fillStyle = block.id === PORTAL_ID ? "#4a148c" : "#424242";
        ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
        ctx.strokeStyle = block.id === PORTAL_ID ? "#ce93d8" : "#b0bec5";
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);

        if (block.emoji) {
          ctx.font = Math.floor(TILE_SIZE * 0.6) + "px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(block.emoji, px + TILE_SIZE / 2, py + TILE_SIZE / 2 + 1);
        }
      }
    }

    function drawPlayer() {
      const screenX = player.x - cameraX;
      const screenY = player.y - cameraY;
      if (screenX < 0 || screenX >= VIEW_W || screenY < 0 || screenY >= VIEW_H) return;

      const px = screenX * TILE_SIZE;
      const py = screenY * TILE_SIZE;

      ctx.fillStyle = "#2196f3";
      ctx.fillRect(px + TILE_SIZE * 0.25, py + TILE_SIZE * 0.2, TILE_SIZE * 0.5, TILE_SIZE * 0.5);

      ctx.fillStyle = "#ffcc80";
      ctx.fillRect(px + TILE_SIZE * 0.3, py + TILE_SIZE * 0.02, TILE_SIZE * 0.4, TILE_SIZE * 0.45);

      ctx.fillStyle = "#000";
      ctx.fillRect(px + TILE_SIZE * 0.35, py + TILE_SIZE * 0.18, TILE_SIZE * 0.07, TILE_SIZE * 0.07);
      ctx.fillRect(px + TILE_SIZE * 0.58, py + TILE_SIZE * 0.18, TILE_SIZE * 0.07, TILE_SIZE * 0.07);

      const cx = px + TILE_SIZE / 2;
      const cy = py + TILE_SIZE / 2;
      ctx.strokeStyle = "#ffff00";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + player.dirX * (TILE_SIZE * 0.3), cy + player.dirY * (TILE_SIZE * 0.3));
      ctx.stroke();
    }

    function drawPlayerHP() {
      const margin = 8;
      const barWidth = 140;
      const barHeight = 10;
      const x = margin;
      const y = margin;

      const ratio = Math.max(0, player.hp / player.maxHp);
      const filled = barWidth * ratio;

      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(x - 4, y - 6, barWidth + 8, barHeight + 22);

      ctx.fillStyle = "#440000";
      ctx.fillRect(x, y, barWidth, barHeight);
      ctx.fillStyle = "#00e676";
      ctx.fillRect(x, y, filled, barHeight);

      ctx.font = "12px system-ui";
      ctx.fillStyle = "#ffffff";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText(`HP: ${player.hp} / ${player.maxHp}`, x, y + barHeight + 4);
    }

    function render() {
      const now = performance.now();
      const dt = now - lastTime;
      lastTime = now;

      updateHitEffects(dt);

      // Player HP regen if safe
      if (player.hp < player.maxHp) {
        if (!anyMobWithinRadius(REGEN_RADIUS)) {
          regenTimerMs += dt;
          while (regenTimerMs >= REGEN_INTERVAL_MS && player.hp < player.maxHp) {
            player.hp += 1;
            regenTimerMs -= REGEN_INTERVAL_MS;
          }
        } else {
          regenTimerMs = 0;
        }
      } else {
        regenTimerMs = 0;
      }

      // Mob regen (bigger mobs heal slower)
      updateMobRegen(dt);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let sy = 0; sy < VIEW_H; sy++) {
        const wy = sy + cameraY;
        if (wy < 0 || wy >= WORLD_H) continue;
        for (let sx = 0; sx < VIEW_W; sx++) {
          const wx = sx + cameraX;
          if (wx < 0 || wx >= WORLD_W) continue;
          const tileId = worldBlocks[wy][wx];
          const biomeId = worldBiome[wy][wx];
          drawTile(tileId, biomeId, sx, sy);
        }
      }

      drawMobs();

      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      const screenFrontX = tx - cameraX;
      const screenFrontY = ty - cameraY;
      if (screenFrontX >= 0 && screenFrontY >= 0 &&
          screenFrontX < VIEW_W && screenFrontY < VIEW_H) {
        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          screenFrontX * TILE_SIZE + 2,
          screenFrontY * TILE_SIZE + 2,
          TILE_SIZE - 4,
          TILE_SIZE - 4
        );
      }

      drawPlayer();
      drawHitEffects();
      drawPlayerHP();

      // Combat border
      if (anyMobWithinRadius(COMBAT_RADIUS)) {
        ctx.strokeStyle = "rgba(255,0,0,0.85)";
        ctx.lineWidth = 6;
        ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);
      }

      requestAnimationFrame(render);
    }

    // Movement / actions
    function movePlayer(dx, dy) {
      if (dx === 0 && dy === 0) return;
      player.dirX = dx;
      player.dirY = dy;
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (isWalkable(nx, ny)) {
        player.x = nx;
        player.y = ny;
        updateCamera();
        checkPortal();
      }
    }

    function placeBlock() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return;
      if (tx === 0 || ty === 0 || tx === WORLD_W - 1 || ty === WORLD_H - 1) return;
      if (tx === player.x && ty === player.y) return;
      if (isMobAt(tx, ty)) return;
      worldBlocks[ty][tx] = selectedBlockId;
    }

    function removeBlock() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return;
      if (tx === 0 || ty === 0 || tx === WORLD_W - 1 || ty === WORLD_H - 1) return;
      worldBlocks[ty][tx] = 0;
    }

    // Save / load
    function saveWorld() {
      const data = {
        biome: worldBiome,
        blocks: worldBlocks,
        player: { ...player },
        mobs: mobs.map(m => ({ ...m })),
        portals: portals.map(p => ({ ...p }))
      };
      try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        alert("World saved!");
      } catch (e) {
        console.error(e);
        alert("Failed to save (localStorage error).");
      }
    }

    function loadWorld() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) {
        alert("No saved world found.");
        return;
      }
      try {
        const data = JSON.parse(raw);
        if (!Array.isArray(data.blocks) || !Array.isArray(data.biome)) {
          throw new Error("Invalid world data");
        }
        if (data.blocks.length !== WORLD_H || data.blocks[0].length !== WORLD_W) {
          throw new Error("Saved world size mismatch");
        }
        worldBlocks = data.blocks.map(row => row.slice());
        worldBiome  = data.biome.map(row => row.slice());
        if (data.player) {
          player.x = data.player.x ?? player.x;
          player.y = data.player.y ?? player.y;
          player.dirX = data.player.dirX ?? player.dirX;
          player.dirY = data.player.dirY ?? player.dirY;
          player.maxHp = data.player.maxHp ?? PLAYER_MAX_HP;
          player.hp = data.player.hp ?? player.maxHp;
        }
        mobs.length = 0;
        if (Array.isArray(data.mobs)) {
          for (const m of data.mobs) {
            const typeIndex = m.typeIndex ?? 0;
            const size = mobTypeSize(typeIndex);
            const defaultHp = defaultHpForSize(size);
            mobs.push({
              x: m.x,
              y: m.y,
              typeIndex,
              dirX: m.dirX ?? 0,
              dirY: m.dirY ?? 0,
              hp: m.hp ?? defaultHp,
              maxHp: m.maxHp ?? defaultHp,
              mode: m.mode ?? "idle",
              regenTimerMs: m.regenTimerMs ?? 0
            });
          }
        }
        portals.length = 0;
        if (Array.isArray(data.portals)) {
          for (const p of data.portals) portals.push({ ...p });
        }
        updateCamera();
        alert("World loaded!");
      } catch (e) {
        console.error(e);
        alert("Failed to load world (data corrupted?).");
      }
    }

    // Inventory & search
    const inventoryList = document.getElementById("inventoryList");
    const blockSearch = document.getElementById("blockSearch");

    function createInventorySlots() {
      inventoryList.innerHTML = "";
      for (let i = 1; i < BLOCKS.length; i++) {
        const b = BLOCKS[i];
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.blockId = String(b.id);
        slot.dataset.name = b.name.toLowerCase();

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "slot-emoji";
        emojiSpan.textContent = b.emoji || "â–¡";
        const nameSpan = document.createElement("div");
        nameSpan.className = "slot-name";
        nameSpan.textContent = b.name;

        slot.appendChild(emojiSpan);
        slot.appendChild(nameSpan);

        slot.addEventListener("click", () => {
          setSelectedBlock(b.id);
        });
        slot.addEventListener("touchstart", (e) => {
          e.preventDefault();
          setSelectedBlock(b.id);
        });

        inventoryList.appendChild(slot);
      }
    }

    function setSelectedBlock(blockId) {
      selectedBlockId = blockId;
      const slots = inventoryList.querySelectorAll(".slot");
      slots.forEach(slot => {
        slot.classList.toggle(
          "selected",
          Number(slot.dataset.blockId) === blockId
        );
      });
    }

    function filterInventory() {
      const q = (blockSearch.value || "").trim().toLowerCase();
      const slots = inventoryList.querySelectorAll(".slot");
      slots.forEach(slot => {
        const name = slot.dataset.name || "";
        slot.style.display = name.includes(q) ? "inline-flex" : "none";
      });
    }

    blockSearch.addEventListener("input", filterInventory);

    // Keyboard input
    window.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (["arrowup", "arrowdown", "arrowleft", "arrowright", " "].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
      switch (key) {
        case "w":
        case "arrowup":
          movePlayer(0, -1);
          break;
        case "s":
        case "arrowdown":
          movePlayer(0, 1);
          break;
        case "a":
        case "arrowleft":
          movePlayer(-1, 0);
          break;
        case "d":
        case "arrowright":
          movePlayer(1, 0);
          break;
        case " ":
          placeBlock();
          break;
        case "x":
          removeBlock();
          break;
        case "z":
          hitMob();
          break;
        case "+":
        case "=":
          changeZoom(1);
          break;
        case "-":
          changeZoom(-1);
          break;
        case "1":
          setSelectedBlock(WALL_ID);
          break;
        case "2":
          setSelectedBlock(findBlockId("bed"));
          break;
        case "3":
          setSelectedBlock(findBlockId("table"));
          break;
        case "4":
          setSelectedBlock(findBlockId("sofa"));
          break;
      }
    });

    // Mouse input
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      const sx = Math.floor(mx / TILE_SIZE);
      const sy = Math.floor(my / TILE_SIZE);

      const tx = sx + cameraX;
      const ty = sy + cameraY;

      const dx = tx - player.x;
      const dy = ty - player.y;
      if (dx !== 0 || dy !== 0) {
        if (Math.abs(dx) > Math.abs(dy)) {
          player.dirX = dx > 0 ? 1 : -1;
          player.dirY = 0;
        } else {
          player.dirX = 0;
          player.dirY = dy > 0 ? 1 : -1;
        }
      }

      if (e.button === 0) {
        placeBlock();
      } else if (e.button === 2) {
        removeBlock();
      }
    });

    // Touch buttons
    document.querySelectorAll(".dpad-btn").forEach(btn => {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const [dx, dy] = btn.dataset.move.split(",").map(Number);
        movePlayer(dx, dy);
      });
    });

    document.querySelectorAll(".touch-action-btn").forEach(btn => {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const action = btn.dataset.action;
        if (action === "place") placeBlock();
        if (action === "remove") removeBlock();
        if (action === "hit") hitMob();
        if (action === "zoomIn") changeZoom(1);
        if (action === "zoomOut") changeZoom(-1);
      });
    });

    // Save/load buttons
    document.getElementById("saveBtn").addEventListener("click", saveWorld);
    document.getElementById("loadBtn").addEventListener("click", loadWorld);
    document.getElementById("saveBtn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      saveWorld();
    });
    document.getElementById("loadBtn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      loadWorld();
    });

    // Init
    createInventorySlots();
    setSelectedBlock(WALL_ID);
    filterInventory();
    resizeCanvas();
    initWorld();
    render();
    setInterval(updateMobs, 300);
  </script>
</body>
</html>
