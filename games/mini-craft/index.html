<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MiniCraft â€“ 200+ Furnitures + Mobs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    #gameContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: #66bb6a;
      image-rendering: pixelated;
      border: 2px solid #444;
      max-width: 100vw;
      max-height: calc(100vh - 230px);
      touch-action: none;
    }

    /* TOP inventory + search + save/load */
    #uiBar {
      background: #222;
      padding: 6px 10px;
      font-size: 13px;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) auto;
      gap: 8px;
      align-items: stretch;
      border-top: 1px solid #333;
    }

    #inventoryPanel {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    #inventoryHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      font-size: 12px;
    }

    #blockSearch {
      flex: 1;
      padding: 3px 6px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #eee;
      font-size: 12px;
    }

    #inventoryList {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-height: 80px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .slot {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      border-radius: 6px;
      border: 2px solid #555;
      box-sizing: border-box;
      background: #333;
      cursor: pointer;
      user-select: none;
      font-size: 20px;
    }
    .slot span.slot-emoji {
      pointer-events: none;
    }
    .slot.selected {
      border-color: #ffeb3b;
      box-shadow: 0 0 8px #ffeb3b;
    }
    .slot-name {
      font-size: 9px;
      color: #ccc;
      text-align: center;
      pointer-events: none;
      line-height: 1.1;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #help {
      font-size: 11px;
      color: #ccc;
      align-self: center;
    }

    #saveLoadButtons {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-end;
      justify-content: center;
    }

    button {
      background: #424242;
      border: 1px solid #666;
      border-radius: 4px;
      color: #eee;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
    }
    button:active {
      background: #616161;
    }

    /* Touch controls for mobile (bottom) */
    #touchControls {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 6px 0 8px;
      gap: 12px;
      background: #181818;
      border-top: 1px solid #333;
    }
    #dpad {
      display: grid;
      grid-template-columns: 40px 40px 40px;
      grid-template-rows: 40px 40px 40px;
      gap: 4px;
    }
    .dpad-btn {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #303030;
      border-radius: 6px;
      border: 1px solid #555;
      font-size: 18px;
      user-select: none;
    }
    .dpad-btn:active {
      background: #505050;
    }
    .dpad-empty {
      background: transparent;
      border: none;
    }
    #touchActions {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .touch-action-btn {
      width: 80px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: #37474f;
      border: 1px solid #607d8b;
      font-size: 12px;
      user-select: none;
    }
    .touch-action-btn:active {
      background: #546e7a;
    }

    /* Hide touch controls on big screens */
    @media (min-width: 768px) {
      #touchControls {
        display: none;
      }
    }

    @media (max-width: 600px) {
      #uiBar {
        grid-template-columns: minmax(0, 1.7fr) minmax(0, 1.3fr);
        grid-template-rows: auto auto;
      }
      #saveLoadButtons {
        flex-direction: row;
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="480"></canvas>
  </div>

  <!-- Mobile / touch controls -->
  <div id="touchControls">
    <div id="dpad">
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="0,-1">â–²</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="-1,0">â—€</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="1,0">â–¶</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-move="0,1">â–¼</div>
      <div class="dpad-empty"></div>
    </div>
    <div id="touchActions">
      <div class="touch-action-btn" data-action="place">Place</div>
      <div class="touch-action-btn" data-action="remove">Remove</div>
    </div>
  </div>

  <!-- Inventory + search + save/load -->
  <div id="uiBar">
    <div id="inventoryPanel">
      <div id="inventoryHeader">
        <span>Furniture (click to select)</span>
        <input id="blockSearch" type="text" placeholder="Search: bed, sofa, lamp..." />
      </div>
      <div id="inventoryList"></div>
    </div>
    <div id="help">
      PC: WASD / Arrows to move, Space = Place, X = Remove, 1=Wall, 2/3/4 = common furniture.  
      Mobile: Use D-pad & Place/Remove buttons.
    </div>
    <div id="saveLoadButtons">
      <button id="saveBtn">ðŸ’¾ Save World</button>
      <button id="loadBtn">ðŸ“‚ Load World</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const TILE_SIZE = 32;
    const WORLD_W = Math.floor(canvas.width / TILE_SIZE);
    const WORLD_H = Math.floor(canvas.height / TILE_SIZE);

    // ---------- BIG EMOJI POOL ----------
    const emojiPool = [
      "ðŸ›ï¸","ðŸª‘","ðŸ›‹ï¸","ðŸ’¡","ðŸª´","ðŸ“º","ðŸ“š","ðŸ’»","ðŸ§Š","ðŸ§°","ðŸ‘•","ðŸ§¶","ðŸš°","ðŸ³","ðŸŽ¹",
      "ðŸ½ï¸","â˜•","ðŸ·","ðŸ“¦","ðŸ§º","ðŸ§´","ðŸ§¼","ðŸ§»","ðŸª¥","ðŸš¿","ðŸ§½","ðŸ•¯ï¸","ðŸ§¸","ðŸŽ®","ðŸŽ§",
      "ðŸ“€","ðŸ“»","ðŸ“ ","ðŸ®","ðŸªŸ","ðŸšª","ðŸ§±","ðŸŽ²","â™Ÿï¸","ðŸŽ¯","ðŸ†","ðŸŽ¤",
      "ðŸŽ¼","ðŸŽ¨","ðŸ–¼ï¸","ðŸ§µ","ðŸª¡","ðŸ§·","ðŸ“Œ","ðŸ“Ž","ðŸ—‚ï¸","ðŸ—„ï¸","ðŸªœ","ðŸ§¯","ðŸ§¹","ðŸª£",
      "ðŸº","â°","âŒ›","â³","ðŸ§­","ðŸ’Ž","ðŸ”‘","ðŸ”’","ðŸ”“","ðŸ§ª","ðŸ§«","ðŸ§¬",
      "ðŸ¯","ðŸ¥«","ðŸª","ðŸ°","ðŸ“","ðŸŠ","ðŸŽ","ðŸ‡","ðŸŒ","ðŸ‰","ðŸ","ðŸ¥","ðŸ¥‘",
      "ðŸ•","ðŸ”","ðŸŒ­","ðŸŸ","ðŸ¥ª","ðŸŒ®","ðŸ™","ðŸ£","ðŸ¤","ðŸœ","ðŸ›","ðŸš","ðŸ¥˜","ðŸ²",
      "ðŸŒ¸","ðŸŒ¼","ðŸŒ»","ðŸŒµ","ðŸŒ´","ðŸŒ³","ðŸŽ‹","ðŸŽ","ðŸ€","ðŸ","ðŸ‚","ðŸƒ","ðŸŸ","ðŸ ","ðŸ¡",
      "ðŸ’ ","ðŸ”·","ðŸ”¶","ðŸ”º","ðŸ”»","âšª","âš«","ðŸ”˜","ðŸ”²","ðŸ”³","ðŸŸ¥","ðŸŸ§","ðŸŸ¨","ðŸŸ©","ðŸŸ¦",
      "ðŸŸª","â¬œ","â¬›","â—¼ï¸","â—»ï¸","â–«ï¸","â–ªï¸","âœ³ï¸","âœ´ï¸","â‡ï¸","â­","ðŸŒŸ","âœ¨","ðŸ’«","ðŸ”¥",
      "ðŸ””","ðŸ“˜","ðŸ“™","ðŸ“—","ðŸ“•","ðŸ“’","ðŸ““","ðŸ“”","ðŸ“š","ðŸ“","ðŸ“","âœ‚ï¸","ðŸ–Šï¸"
    ];

    // -------- BLOCK DEFINITIONS (200+ furniture) --------
    const BLOCKS = [
      { id: 0, key: "empty", name: "Empty", emoji: "", solid: false }
    ];

    // add wood wall (border, solid)
    const WALL_ID = BLOCKS.length;
    BLOCKS.push({
      id: WALL_ID,
      key: "wood_wall",
      name: "Wood Wall",
      emoji: "ðŸ§±",
      solid: true
    });

    // base furniture types (15 kinds)
    const furnitureBases = [
      { baseKey: "bed",       baseName: "Bed" },
      { baseKey: "table",     baseName: "Table" },
      { baseKey: "sofa",      baseName: "Sofa" },
      { baseKey: "lamp",      baseName: "Lamp" },
      { baseKey: "plant",     baseName: "Plant" },
      { baseKey: "tv",        baseName: "TV" },
      { baseKey: "bookshelf", baseName: "Bookshelf" },
      { baseKey: "pcdesk",    baseName: "PC Desk" },
      { baseKey: "fridge",    baseName: "Fridge" },
      { baseKey: "drawer",    baseName: "Drawer" },
      { baseKey: "wardrobe",  baseName: "Wardrobe" },
      { baseKey: "rug",       baseName: "Rug" },
      { baseKey: "sink",      baseName: "Sink" },
      { baseKey: "stove",     baseName: "Stove" },
      { baseKey: "piano",     baseName: "Piano" }
    ];

    // style names (15) -> 15 * 15 = 225 furniture types
    const styleNames = [
      "Oak", "Birch", "Spruce", "Dark", "Light",
      "Modern", "Classic", "Compact", "Wide", "Tall",
      "Corner", "Deluxe", "Simple", "Fancy", "Industrial"
    ];

    for (let i = 0; i < furnitureBases.length; i++) {
      for (let j = 0; j < styleNames.length; j++) {
        const base = furnitureBases[i];
        const style = styleNames[j];
        const id = BLOCKS.length;
        const emoji = emojiPool[id % emojiPool.length] || "â–¡";
        BLOCKS.push({
          id,
          key: `${base.baseKey}_${style.toLowerCase()}`,
          name: `${style} ${base.baseName}`,
          emoji: emoji,
          solid: false
        });
      }
    }

    function findBlockId(keyStartsWith) {
      const lower = keyStartsWith.toLowerCase();
      for (const b of BLOCKS) {
        if (b.key.startsWith(lower)) return b.id;
      }
      return WALL_ID;
    }

    // -------- WORLD & PLAYER --------
    const player = {
      x: Math.floor(WORLD_W / 2),
      y: Math.floor(WORLD_H / 2),
      dirX: 0,
      dirY: -1
    };

    let world = [];
    let selectedBlockId = WALL_ID;
    const SAVE_KEY = "minicraftFurnitureWorld_withMobs";

    // -------- MOBS (movable animals) --------
    const mobs = [];
    const MOB_TYPES = [
      { name: "Cow",    emoji: "ðŸ„" },
      { name: "Pig",    emoji: "ðŸ–" },
      { name: "Sheep",  emoji: "ðŸ‘" },
      { name: "Chicken",emoji: "ðŸ”" },
      { name: "Cat",    emoji: "ðŸ±" },
      { name: "Dog",    emoji: "ðŸ¶" },
      { name: "Fox",    emoji: "ðŸ¦Š" },
      { name: "Panda",  emoji: "ðŸ¼" },
      { name: "Rabbit", emoji: "ðŸ°" },
      { name: "Parrot", emoji: "ðŸ¦œ" }
    ];

    function isMobAt(x, y) {
      return mobs.some(m => m.x === x && m.y === y);
    }

    function addRandomMob(typeIndex) {
      let tries = 0;
      while (tries < 200) {
        const x = 2 + Math.floor(Math.random() * (WORLD_W - 4));
        const y = 2 + Math.floor(Math.random() * (WORLD_H - 4));
        if (!isWalkableBase(x, y)) { tries++; continue; }
        if (isMobAt(x, y)) { tries++; continue; }
        if (x === player.x && y === player.y) { tries++; continue; }
        mobs.push({
          x,
          y,
          typeIndex: typeIndex % MOB_TYPES.length,
          dirX: 0,
          dirY: 0
        });
        return;
      }
    }

    function initMobs() {
      mobs.length = 0;
      const mobCount = 12;
      for (let i = 0; i < mobCount; i++) {
        addRandomMob(i);
      }
    }

    // basic walkability ignoring mobs
    function isWalkableBase(x, y) {
      if (x < 0 || y < 0 || x >= WORLD_W || y >= WORLD_H) return false;
      const tileId = world[y][x];
      const block = BLOCKS[tileId] || BLOCKS[0];
      return !block.solid;
    }

    function updateMobs() {
      for (const mob of mobs) {
        // sometimes change direction
        if (Math.random() < 0.4 || (mob.dirX === 0 && mob.dirY === 0)) {
          const dirs = [
            {dx: 1, dy: 0},
            {dx: -1, dy: 0},
            {dx: 0, dy: 1},
            {dx: 0, dy: -1},
            {dx: 0, dy: 0}
          ];
          const choice = dirs[Math.floor(Math.random() * dirs.length)];
          mob.dirX = choice.dx;
          mob.dirY = choice.dy;
        }

        if (mob.dirX === 0 && mob.dirY === 0) continue;

        const nx = mob.x + mob.dirX;
        const ny = mob.y + mob.dirY;

        if (!isWalkableBase(nx, ny)) continue;
        if (isMobAt(nx, ny)) continue;
        if (nx === player.x && ny === player.y) continue;

        mob.x = nx;
        mob.y = ny;
      }
    }

    function drawMobs() {
      for (const mob of mobs) {
        const px = mob.x * TILE_SIZE;
        const py = mob.y * TILE_SIZE;
        const mobType = MOB_TYPES[mob.typeIndex] || MOB_TYPES[0];

        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(mobType.emoji, px + TILE_SIZE / 2, py + TILE_SIZE / 2 + 2);
      }
    }

    function initWorld() {
      world = [];
      for (let y = 0; y < WORLD_H; y++) {
        const row = [];
        for (let x = 0; x < WORLD_W; x++) {
          if (x === 0 || y === 0 || x === WORLD_W - 1 || y === WORLD_H - 1) {
            row.push(WALL_ID);
          } else {
            row.push(0);
          }
        }
        world.push(row);
      }

      // simple house
      const hx = 3, hy = 3, hw = 10, hh = 8;
      for (let y = hy; y < hy + hh; y++) {
        for (let x = hx; x < hx + hw; x++) {
          if (x === hx || y === hy || x === hx + hw - 1 || y === hy + hh - 1) {
            world[y][x] = WALL_ID;
          } else {
            world[y][x] = 0;
          }
        }
      }

      // starter furniture
      const bedId   = findBlockId("bed");
      const tableId = findBlockId("table");
      const sofaId  = findBlockId("sofa");
      const plantId = findBlockId("plant");

      world[hy + hh - 2][hx + 1] = bedId;
      world[hy + hh - 3][hx + 3] = tableId;
      world[hy + hh - 3][hx + 5] = sofaId;
      world[hy + 1][hx + 2]     = plantId;

      player.x = hx + Math.floor(hw / 2);
      player.y = hy + Math.floor(hh / 2);
      player.dirX = 0;
      player.dirY = -1;

      initMobs();
    }

    // -------- DRAWING --------
    function drawTile(tileId, x, y) {
      const px = x * TILE_SIZE;
      const py = y * TILE_SIZE;

      ctx.fillStyle = (x + y) % 2 === 0 ? "#5da15d" : "#579957";
      ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

      if (tileId === 0) return;

      const block = BLOCKS[tileId] || BLOCKS[0];

      if (block.id === WALL_ID) {
        ctx.fillStyle = "#8d6e63";
        ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 2;
        ctx.strokeRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6);
      } else {
        ctx.fillStyle = "#424242";
        ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
        ctx.strokeStyle = "#b0bec5";
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);

        if (block.emoji) {
          ctx.font = "18px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#ffffff";
          ctx.fillText(block.emoji, px + TILE_SIZE / 2, py + TILE_SIZE / 2 + 1);
        }
      }
    }

    function drawPlayer() {
      const px = player.x * TILE_SIZE;
      const py = player.y * TILE_SIZE;

      ctx.fillStyle = "#2196f3";
      ctx.fillRect(px + 8, py + 6, TILE_SIZE - 16, TILE_SIZE - 10);

      ctx.fillStyle = "#ffcc80";
      ctx.fillRect(px + 10, py, TILE_SIZE - 20, TILE_SIZE / 2 - 2);

      ctx.fillStyle = "#000";
      ctx.fillRect(px + 13, py + 6, 2, 2);
      ctx.fillRect(px + TILE_SIZE - 15, py + 6, 2, 2);

      const cx = px + TILE_SIZE / 2;
      const cy = py + TILE_SIZE / 2;
      ctx.strokeStyle = "#ffff00";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + player.dirX * 10, cy + player.dirY * 10);
      ctx.stroke();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < WORLD_H; y++) {
        for (let x = 0; x < WORLD_W; x++) {
          drawTile(world[y][x], x, y);
        }
      }

      // draw mobs between tiles and player
      drawMobs();

      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx >= 0 && ty >= 0 && tx < WORLD_W && ty < WORLD_H) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
        ctx.lineWidth = 2;
        ctx.strokeRect(tx * TILE_SIZE + 2, ty * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
      }

      drawPlayer();
      requestAnimationFrame(render);
    }

    // -------- LOGIC --------
    function isWalkable(x, y) {
      if (!isWalkableBase(x, y)) return false;
      if (isMobAt(x, y)) return false;
      return true;
    }

    function movePlayer(dx, dy) {
      if (dx === 0 && dy === 0) return;
      player.dirX = dx;
      player.dirY = dy;
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (isWalkable(nx, ny)) {
        player.x = nx;
        player.y = ny;
      }
    }

    function placeBlock() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return;
      if (tx === 0 || ty === 0 || tx === WORLD_W - 1 || ty === WORLD_H - 1) return;
      if (tx === player.x && ty === player.y) return;
      if (isMobAt(tx, ty)) return; // don't place on mobs
      world[ty][tx] = selectedBlockId;
    }

    function removeBlock() {
      const tx = player.x + player.dirX;
      const ty = player.y + player.dirY;
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return;
      if (tx === 0 || ty === 0 || tx === WORLD_W - 1 || ty === WORLD_H - 1) return;
      world[ty][tx] = 0;
    }

    // -------- SAVE / LOAD --------
    function saveWorld() {
      const data = {
        world,
        player: { ...player },
        mobs: mobs.map(m => ({ ...m }))
      };
      try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        alert("World saved!");
      } catch (e) {
        console.error(e);
        alert("Failed to save (localStorage error).");
      }
    }

    function loadWorld() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) {
        alert("No saved world found.");
        return;
      }
      try {
        const data = JSON.parse(raw);
        if (!data.world || !Array.isArray(data.world)) {
          throw new Error("Invalid world data");
        }
        if (data.world.length !== WORLD_H || data.world[0].length !== WORLD_W) {
          throw new Error("Saved world size mismatch");
        }
        world = data.world.map(row => row.slice());
        if (data.player) {
          player.x = data.player.x ?? player.x;
          player.y = data.player.y ?? player.y;
          player.dirX = data.player.dirX ?? player.dirX;
          player.dirY = data.player.dirY ?? player.dirY;
        }
        mobs.length = 0;
        if (Array.isArray(data.mobs)) {
          for (const m of data.mobs) {
            mobs.push({ ...m });
          }
        }
        alert("World loaded!");
      } catch (e) {
        console.error(e);
        alert("Failed to load world (data corrupted?).");
      }
    }

    // -------- INVENTORY & SEARCH --------
    const inventoryList = document.getElementById("inventoryList");
    const blockSearch = document.getElementById("blockSearch");

    function createInventorySlots() {
      inventoryList.innerHTML = "";
      for (let i = 1; i < BLOCKS.length; i++) {
        const b = BLOCKS[i];
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.blockId = String(b.id);
        slot.dataset.name = b.name.toLowerCase();

        const emojiSpan = document.createElement("span");
        emojiSpan.className = "slot-emoji";
        emojiSpan.textContent = b.emoji || "â–¡";
        const nameSpan = document.createElement("div");
        nameSpan.className = "slot-name";
        nameSpan.textContent = b.name;

        slot.appendChild(emojiSpan);
        slot.appendChild(nameSpan);

        slot.addEventListener("click", () => {
          setSelectedBlock(b.id);
        });
        slot.addEventListener("touchstart", (e) => {
          e.preventDefault();
          setSelectedBlock(b.id);
        });

        inventoryList.appendChild(slot);
      }
    }

    function setSelectedBlock(blockId) {
      selectedBlockId = blockId;
      const slots = inventoryList.querySelectorAll(".slot");
      slots.forEach(slot => {
        slot.classList.toggle(
          "selected",
          Number(slot.dataset.blockId) === blockId
        );
      });
    }

    function filterInventory() {
      const q = (blockSearch.value || "").trim().toLowerCase();
      const slots = inventoryList.querySelectorAll(".slot");
      slots.forEach(slot => {
        const name = slot.dataset.name || "";
        slot.style.display = name.includes(q) ? "inline-flex" : "none";
      });
    }

    blockSearch.addEventListener("input", filterInventory);

    // -------- INPUT: KEYBOARD --------
    window.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (["arrowup", "arrowdown", "arrowleft", "arrowright", " "].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
      switch (key) {
        case "w":
        case "arrowup":
          movePlayer(0, -1);
          break;
        case "s":
        case "arrowdown":
          movePlayer(0, 1);
          break;
        case "a":
        case "arrowleft":
          movePlayer(-1, 0);
          break;
        case "d":
        case "arrowright":
          movePlayer(1, 0);
          break;
        case " ":
          placeBlock();
          break;
        case "x":
          removeBlock();
          break;
        case "1":
          setSelectedBlock(WALL_ID);
          break;
        case "2":
          setSelectedBlock(findBlockId("bed"));
          break;
        case "3":
          setSelectedBlock(findBlockId("table"));
          break;
        case "4":
          setSelectedBlock(findBlockId("sofa"));
          break;
      }
    });

    // -------- INPUT: MOUSE CLICK ON CANVAS --------
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      const tx = Math.floor(mx / TILE_SIZE);
      const ty = Math.floor(my / TILE_SIZE);

      const dx = tx - player.x;
      const dy = ty - player.y;
      if (dx !== 0 || dy !== 0) {
        if (Math.abs(dx) > Math.abs(dy)) {
          player.dirX = dx > 0 ? 1 : -1;
          player.dirY = 0;
        } else {
          player.dirX = 0;
          player.dirY = dy > 0 ? 1 : -1;
        }
      }

      if (e.button === 0) {
        placeBlock();
      } else if (e.button === 2) {
        removeBlock();
      }
    });

    // -------- INPUT: TOUCH BUTTONS --------
    document.querySelectorAll(".dpad-btn").forEach(btn => {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const [dx, dy] = btn.dataset.move.split(",").map(Number);
        movePlayer(dx, dy);
      });
    });

    document.querySelectorAll(".touch-action-btn").forEach(btn => {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const action = btn.dataset.action;
        if (action === "place") placeBlock();
        if (action === "remove") removeBlock();
      });
    });

    // -------- SAVE/LOAD BUTTONS --------
    document.getElementById("saveBtn").addEventListener("click", saveWorld);
    document.getElementById("loadBtn").addEventListener("click", loadWorld);
    document.getElementById("saveBtn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      saveWorld();
    });
    document.getElementById("loadBtn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      loadWorld();
    });

    // -------- INIT --------
    initWorld();
    createInventorySlots();
    setSelectedBlock(WALL_ID);
    filterInventory();
    render();
    // mobs move every 300ms
    setInterval(updateMobs, 300);
  </script>
</body>
</html>
