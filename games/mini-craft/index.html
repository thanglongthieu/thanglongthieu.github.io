<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini-Craft Style Game (Phaser 3)</title>
  <!-- iPhone 対応用の viewport -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <!-- PWA 風フルスクリーン用（ホーム画面から起動したとき） -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* スクロール禁止 */
      background: #111;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-text-size-adjust: 100%;
    }

    /* iPhone のセーフエリア対応（ノッチの部分） */
    body {
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing: border-box;
    }

    #game {
      width: 100%;
      height: 100%;
      touch-action: none; /* 画面スクロールジェスチャー抑制 */
    }
  </style>
</head>
<body>
  <div id="game"></div>

  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <script>
    // ====== CONSTANTS ======
    const TILE_SIZE = 32;
    const WORLD_WIDTH = 100;
    const WORLD_HEIGHT = 40;

    const BLOCK = {
      AIR: 0,
      GRASS: 1,
      DIRT: 2,
      STONE: 3,
      WOOD: 4,
      WATER: 5,
    };

    const BLOCK_COLORS = {
      [BLOCK.AIR]: null,
      [BLOCK.GRASS]: 0x4caf50,
      [BLOCK.DIRT]: 0x8d6e63,
      [BLOCK.STONE]: 0x9e9e9e,
      [BLOCK.WOOD]: 0x795548,
      [BLOCK.WATER]: 0x2196f3,
    };

    const BLOCK_NAMES = {
      [BLOCK.GRASS]: "Grass",
      [BLOCK.DIRT]: "Dirt",
      [BLOCK.STONE]: "Stone",
      [BLOCK.WOOD]: "Wood",
      [BLOCK.WATER]: "Water",
    };

    let world = [];

    // ====== WORLD GENERATION ======
    function generateWorld() {
      world = [];
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        world[y] = [];
        for (let x = 0; x < WORLD_WIDTH; x++) {
          const groundLevel = 20 + Math.floor(Math.sin(x / 6) * 3);

          if (y > groundLevel + 4) {
            world[y][x] = BLOCK.STONE;
          } else if (y > groundLevel) {
            world[y][x] = BLOCK.DIRT;
          } else if (y === groundLevel) {
            world[y][x] = BLOCK.GRASS;
          } else {
            world[y][x] = BLOCK.AIR;
          }
        }
      }

      // Simple lakes
      for (let lx = 15; lx < 30; lx++) {
        const gy = 22;
        for (let y = gy; y < gy + 3; y++) {
          if (y >= 0 && y < WORLD_HEIGHT) {
            world[y][lx] = BLOCK.WATER;
          }
        }
      }

      // Simple trees
      for (let i = 5; i < WORLD_WIDTH; i += 18) {
        const trunkX = i;
        const baseY = 19;
        for (let t = 0; t < 4; t++) {
          if (baseY - t >= 0 && baseY - t < WORLD_HEIGHT) {
            world[baseY - t][trunkX] = BLOCK.WOOD;
          }
        }
        for (let dy = -5; dy <= -2; dy++) {
          for (let dx = -3; dx <= 3; dx++) {
            const xx = trunkX + dx;
            const yy = baseY + dy;
            if (
              xx >= 0 &&
              xx < WORLD_WIDTH &&
              yy >= 0 &&
              yy < WORLD_HEIGHT
            ) {
              if (Math.abs(dx) + Math.abs(dy + 3) <= 4) {
                world[yy][xx] = BLOCK.GRASS;
              }
            }
          }
        }
      }
    }

    // ====== COLLISION HELPERS ======
    function tileAt(x, y) {
      if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) {
        return BLOCK.STONE; // outside = solid
      }
      return world[y][x];
    }

    function isSolid(x, y) {
      const t = tileAt(x, y);
      if (t === BLOCK.AIR) return false;
      if (t === BLOCK.WATER) return false; // water is passable
      return true;
    }

    function rectCollidesWithWorld(px, py, pw, ph) {
      const left = Math.floor(px);
      const right = Math.floor(px + pw);
      const top = Math.floor(py);
      const bottom = Math.floor(py + ph);

      for (let y = top; y <= bottom; y++) {
        for (let x = left; x <= right; x++) {
          if (isSolid(x, y)) return true;
        }
      }
      return false;
    }

    function isCollidingWithPlayer(player, tx, ty) {
      const px = player.x;
      const py = player.y;
      const pw = player.width;
      const ph = player.height;

      const tileLeft = tx;
      const tileRight = tx + 1;
      const tileTop = ty;
      const tileBottom = ty + 1;

      const playerLeft = px;
      const playerRight = px + pw;
      const playerTop = py;
      const playerBottom = py + ph;

      return !(
        playerRight <= tileLeft ||
        playerLeft >= tileRight ||
        playerBottom <= tileTop ||
        playerTop >= tileBottom
      );
    }

    // ====== SCENE CLASS ======
    class MiniCraftScene extends Phaser.Scene {
      constructor() {
        super("MiniCraftScene");
      }

      init() {
        this.player = {
          x: 5,
          y: 5,
          width: 0.7,
          height: 1.2,
          vx: 0,
          vy: 0,
          speed: 9,
          jumpPower: 14,
          onGround: false,
        };

        this.selectedBlock = BLOCK.GRASS;
        this.timeOfDay = 0; // 0..1
      }

      preload() {}

      create() {
        generateWorld();

        this.graphics = this.add.graphics();

        // HUD
        this.hudText = this.add
          .text(10, 10, "", {
            fontSize: "14px",
            fill: "#ffffff",
          })
          .setScrollFactor(0);

        this.helpText = this.add
          .text(
            10,
            30,
            "Move: A/D or ←/→ | Jump: W/↑/Space | Break: Left Click | Place: Right Click or Shift+Click | Block: 1-5",
            { fontSize: "12px", fill: "#ffeb3b", wordWrap: { width: 320 } }
          )
          .setScrollFactor(0);

        // Day/Night overlay
        this.dayOverlay = this.add
          .rectangle(0, 0, this.scale.width, this.scale.height, 0x000020, 0)
          .setOrigin(0, 0)
          .setScrollFactor(0);

        // Camera bounds
        this.cameras.main.setBounds(
          0,
          0,
          WORLD_WIDTH * TILE_SIZE,
          WORLD_HEIGHT * TILE_SIZE
        );

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys({
          W: Phaser.Input.Keyboard.KeyCodes.W,
          A: Phaser.Input.Keyboard.KeyCodes.A,
          S: Phaser.Input.Keyboard.KeyCodes.S,
          D: Phaser.Input.Keyboard.KeyCodes.D,
          SPACE: Phaser.Input.Keyboard.KeyCodes.SPACE,
          SHIFT: Phaser.Input.Keyboard.KeyCodes.SHIFT,
        });

        // Number keys for block selection
        this.input.keyboard.on("keydown", (event) => {
          switch (event.key) {
            case "1":
              this.selectedBlock = BLOCK.GRASS;
              break;
            case "2":
              this.selectedBlock = BLOCK.DIRT;
              break;
            case "3":
              this.selectedBlock = BLOCK.STONE;
              break;
            case "4":
              this.selectedBlock = BLOCK.WOOD;
              break;
            case "5":
              this.selectedBlock = BLOCK.WATER;
              break;
          }
        });

        // Mouse actions
        this.input.on("pointerdown", (pointer) => {
          const wx = Math.floor(pointer.worldX / TILE_SIZE);
          const wy = Math.floor(pointer.worldY / TILE_SIZE);

          if (
            wx < 0 ||
            wx >= WORLD_WIDTH ||
            wy < 0 ||
            wy >= WORLD_HEIGHT
          ) {
            return;
          }

          const right = pointer.rightButtonDown();
          const shift = pointer.event && pointer.event.shiftKey;

          if (right || shift) {
            // Place block
            if (!isCollidingWithPlayer(this.player, wx, wy)) {
              world[wy][wx] = this.selectedBlock;
            }
          } else {
            // Break block
            world[wy][wx] = BLOCK.AIR;
          }
        });

        // Resize overlay when game size changes
        this.scale.on("resize", (gameSize) => {
          this.dayOverlay.setSize(gameSize.width, gameSize.height);
        });
      }

      update(time, delta) {
        const dt = Math.min(delta / 1000, 0.05);
        this.handleInput(dt);
        this.updateCamera();
        this.updateDayNight(dt);
        this.drawScene();
        this.updateHUD();
      }

      handleInput(dt) {
        let move = 0;
        if (this.keys.A.isDown || this.cursors.left.isDown) move -= 1;
        if (this.keys.D.isDown || this.cursors.right.isDown) move += 1;

        this.player.vx = move * this.player.speed;

        const jumpPressed =
          this.keys.W.isDown ||
          this.cursors.up.isDown ||
          this.keys.SPACE.isDown;

        if (jumpPressed && this.player.onGround) {
          this.player.vy = -this.player.jumpPower;
          this.player.onGround = false;
        }

        // Gravity
        const GRAVITY = 32;
        const MAX_FALL_SPEED = 32;

        this.player.vy += GRAVITY * dt;
        if (this.player.vy > MAX_FALL_SPEED) {
          this.player.vy = MAX_FALL_SPEED;
        }

        // Horizontal movement
        let newX = this.player.x + this.player.vx * dt;
        if (
          !rectCollidesWithWorld(
            newX,
            this.player.y,
            this.player.width,
            this.player.height
          )
        ) {
          this.player.x = newX;
        } else {
          const sign = Math.sign(this.player.vx);
          while (
            !rectCollidesWithWorld(
              this.player.x + sign * 0.01,
              this.player.y,
              this.player.width,
              this.player.height
            )
          ) {
            this.player.x += sign * 0.01;
          }
          this.player.vx = 0;
        }

        // Vertical movement
        let newY = this.player.y + this.player.vy * dt;
        this.player.onGround = false;

        if (
          !rectCollidesWithWorld(
            this.player.x,
            newY,
            this.player.width,
            this.player.height
          )
        ) {
          this.player.y = newY;
        } else {
          if (this.player.vy > 0) {
            this.player.onGround = true;
          }
          const sign = Math.sign(this.player.vy);
          while (
            !rectCollidesWithWorld(
              this.player.x,
              this.player.y + sign * 0.01,
              this.player.width,
              this.player.height
            )
          )
          {
            this.player.y += sign * 0.01;
          }
          this.player.vy = 0;
        }
      }

      updateCamera() {
        const cam = this.cameras.main;
        const centerX =
          (this.player.x + this.player.width / 2) * TILE_SIZE;
        const centerY =
          (this.player.y + this.player.height / 2) * TILE_SIZE;
        cam.centerOn(centerX, centerY);
      }

      updateDayNight(dt) {
        // 1 day cycle ~ 60 seconds
        this.timeOfDay += dt / 60;
        if (this.timeOfDay > 1) this.timeOfDay -= 1;

        const nightStrength =
          0.7 * (0.5 - 0.5 * Math.cos(this.timeOfDay * Math.PI * 2));
        this.dayOverlay.setAlpha(nightStrength);
      }

      drawScene() {
        const g = this.graphics;
        g.clear();

        const cam = this.cameras.main;
        const view = cam.worldView;
        const startX = Math.floor(view.x / TILE_SIZE) - 1;
        const endX = Math.ceil((view.x + view.width) / TILE_SIZE) + 1;
        const startY = Math.floor(view.y / TILE_SIZE) - 1;
        const endY = Math.ceil((view.y + view.height) / TILE_SIZE) + 1;

        // Draw tiles
        for (let y = startY; y <= endY; y++) {
          for (let x = startX; x <= endX; x++) {
            if (
              x < 0 ||
              x >= WORLD_WIDTH ||
              y < 0 ||
              y >= WORLD_HEIGHT
            ) {
              continue;
            }
            const block = world[y][x];
            if (block === BLOCK.AIR) continue;

            const color = BLOCK_COLORS[block];
            if (!color) continue;

            const sx = x * TILE_SIZE;
            const sy = y * TILE_SIZE;

            g.fillStyle(color, 1);
            g.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);

            g.lineStyle(1, 0x000000, 0.08);
            g.strokeRect(sx, sy, TILE_SIZE, TILE_SIZE);
          }
        }

        // Draw player
        const px = this.player.x * TILE_SIZE;
        const py = this.player.y * TILE_SIZE;
        const pw = this.player.width * TILE_SIZE;
        const ph = this.player.height * TILE_SIZE;

        g.fillStyle(0xffeb3b, 1);
        g.fillRect(px, py, pw, ph);
        g.lineStyle(2, 0x000000, 1);
        g.strokeRect(px, py, pw, ph);

        // Cursor highlight
        const pointer = this.input.activePointer;
        const wx = Math.floor(pointer.worldX / TILE_SIZE);
        const wy = Math.floor(pointer.worldY / TILE_SIZE);

        if (
          wx >= 0 &&
          wx < WORLD_WIDTH &&
          wy >= 0 &&
          wy < WORLD_HEIGHT
        ) {
          const cx = wx * TILE_SIZE;
          const cy = wy * TILE_SIZE;
          g.lineStyle(2, 0xffffff, 0.9);
          g.strokeRect(cx, cy, TILE_SIZE, TILE_SIZE);
        }
      }

      updateHUD() {
        const p = this.player;
        this.hudText.setText(
          `Block: ${BLOCK_NAMES[this.selectedBlock]} (1-5) | ` +
          `Pos: (${p.x.toFixed(1)}, ${p.y.toFixed(1)}) | ` +
          `OnGround: ${p.onGround ? "Yes" : "No"}`
        );
      }
    }

    // ====== GAME CONFIG ======
    const config = {
      type: Phaser.AUTO,
      parent: "game",
      backgroundColor: "#87ceeb",
      scene: MiniCraftScene,
      pixelArt: true,
      antialias: false,
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight,
      },
    };

    const game = new Phaser.Game(config);

    // iPhone のアドレスバー表示変更や回転に追従してリサイズ
    function resizeGame() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      game.scale.resize(width, height);
    }

    window.addEventListener("resize", resizeGame);
    window.addEventListener("orientationchange", () => {
      setTimeout(resizeGame, 300); // 回転後に少し待ってから
    });
  </script>
</body>
</html>
