<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MiniCraft 2D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none; /* avoid scrolling on touch */
    }

    #container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    canvas {
      background: #87ceeb; /* sky */
      border-radius: 8px;
      image-rendering: pixelated;
      touch-action: none;
    }

    #hud {
      color: #fff;
      font-size: 14px;
      text-align: center;
    }

    #controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 18px;
      margin-top: 4px;
    }

    .btn-group {
      display: flex;
      gap: 6px;
    }

    button {
      padding: 8px 10px;
      font-size: 16px;
      border-radius: 8px;
      border: none;
      background: #333;
      color: #fff;
      min-width: 40px;
    }

    button:active {
      transform: scale(0.95);
      background: #555;
    }

    #inventory {
      margin-top: 4px;
      display: flex;
      justify-content: center;
      gap: 6px;
      color: #fff;
      font-size: 13px;
      flex-wrap: wrap;
    }

    .slot {
      padding: 3px 6px;
      border-radius: 6px;
      background: #222;
      border: 2px solid #444;
      min-width: 60px;
      text-align: center;
    }

    .slot.selected {
      border-color: #f8e71c;
      box-shadow: 0 0 6px rgba(248,231,28,0.8);
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="game" width="640" height="384"></canvas>
  <div id="hud">
    MiniCraft 2D – tap blocks to mine/place (near player).<br>
    Walk = ◀ ▶, Jump = ⬆, Mode = Break/Place toggle.
  </div>

  <div id="inventory"></div>

  <div id="controls">
    <div class="btn-group">
      <button id="leftBtn">◀</button>
      <button id="rightBtn">▶</button>
    </div>
    <div class="btn-group">
      <button id="jumpBtn">⬆</button>
      <button id="modeBtn">Break</button>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const modeBtn = document.getElementById('modeBtn');
  const inventoryDiv = document.getElementById('inventory');

  // --- World settings ---
  const TILE = 32;
  const WORLD_W = 40;
  const WORLD_H = 16;

  // block ids
  const AIR   = 0;
  const GRASS = 1;
  const DIRT  = 2;
  const STONE = 3;
  const WOOD  = 4;
  const LEAF  = 5;

  const BLOCK_NAMES = {
    [GRASS]: 'Grass',
    [DIRT]:  'Dirt',
    [STONE]: 'Stone',
    [WOOD]:  'Wood',
    [LEAF]:  'Leaf'
  };

  const SOLID = new Set([GRASS, DIRT, STONE, WOOD]);

  let world = [];
  function genWorld() {
    world = [];
    for (let y = 0; y < WORLD_H; y++) {
      const row = [];
      for (let x = 0; x < WORLD_W; x++) {
        row.push(AIR);
      }
      world.push(row);
    }

    // simple terrain
    let baseH = 9;
    for (let x = 0; x < WORLD_W; x++) {
      const hill = Math.floor(Math.sin(x / 4) * 2);
      const groundY = baseH + hill;
      for (let y = groundY; y < WORLD_H; y++) {
        if (y === groundY) world[y][x] = GRASS;
        else if (y < groundY + 3) world[y][x] = DIRT;
        else world[y][x] = STONE;
      }
    }

    // simple trees
    for (let x = 3; x < WORLD_W - 3; x += 7) {
      let groundY = -1;
      for (let y = 0; y < WORLD_H; y++) {
        if (world[y][x] === GRASS) { groundY = y; break; }
      }
      if (groundY !== -1) {
        // trunk
        for (let h = 1; h <= 3; h++) {
          world[groundY - h][x] = WOOD;
        }
        const topY = groundY - 3;
        for (let dx = -2; dx <= 2; dx++) {
          for (let dy = -2; dy <= 0; dy++) {
            const tx = x + dx;
            const ty = topY + dy;
            if (tx >= 0 && tx < WORLD_W && ty >= 0 && ty < WORLD_H) {
              if (world[ty][tx] === AIR) world[ty][tx] = LEAF;
            }
          }
        }
      }
    }
  }

  genWorld();

  // --- Player ---
  const player = {
    x: TILE * 4,
    y: TILE * 6,
    w: TILE * 0.6,
    h: TILE * 1.6,
    vx: 0,
    vy: 0,
    onGround: false
  };

  const GRAV = 1200;    // px/s^2
  const MOVE_SPEED = 220;
  const JUMP_SPEED = 420;

  let keys = {
    left: false,
    right: false,
    jump: false
  };

  let mode = 'break'; // or 'place'
  let selectedBlockType = DIRT;
  const inventory = {
    [GRASS]: 0,
    [DIRT]:  5,
    [STONE]: 0,
    [WOOD]:  0,
    [LEAF]:  0
  };

  function updateInventoryUI() {
    inventoryDiv.innerHTML = '';
    Object.entries(inventory).forEach(([idStr, count]) => {
      const id = Number(idStr);
      if (id === AIR) return;
      const div = document.createElement('div');
      div.className = 'slot' + (id === selectedBlockType ? ' selected' : '');
      div.textContent = `${BLOCK_NAMES[id]}: ${count}`;
      div.dataset.blockId = id;
      inventoryDiv.appendChild(div);
    });
  }

  inventoryDiv.addEventListener('pointerdown', (e) => {
    const slot = e.target.closest('.slot');
    if (!slot) return;
    selectedBlockType = Number(slot.dataset.blockId);
    updateInventoryUI();
  });

  updateInventoryUI();

  // --- Input handlers (buttons) ---
  function bindHoldButton(btn, keyName) {
    btn.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      keys[keyName] = true;
    });
    btn.addEventListener('pointerup', (e) => {
      e.preventDefault();
      keys[keyName] = false;
    });
    btn.addEventListener('pointerleave', (e) => {
      e.preventDefault();
      keys[keyName] = false;
    });
    btn.addEventListener('pointercancel', (e) => {
      e.preventDefault();
      keys[keyName] = false;
    });
  }

  bindHoldButton(leftBtn, 'left');
  bindHoldButton(rightBtn, 'right');

  jumpBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    if (player.onGround) {
      player.vy = -JUMP_SPEED;
      player.onGround = false;
    }
  });

  modeBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    mode = mode === 'break' ? 'place' : 'break';
    modeBtn.textContent = mode === 'break' ? 'Break' : 'Place';
  });

  // keyboard (optional, PC)
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && player.onGround) {
      player.vy = -JUMP_SPEED;
      player.onGround = false;
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
  });

  // --- World helpers ---
  function getBlock(tx, ty) {
    if (tx < 0 || tx >= WORLD_W || ty < 0 || ty >= WORLD_H) return STONE; // solid border
    return world[ty][tx];
  }

  function setBlock(tx, ty, id) {
    if (tx < 0 || tx >= WORLD_W || ty < 0 || ty >= WORLD_H) return;
    world[ty][tx] = id;
  }

  function isSolidBlock(id) {
    return SOLID.has(id);
  }

  // --- Physics / collision ---
  function rectVsWorldCollide(px, py, w, h) {
    const left   = Math.floor((px - w / 2) / TILE);
    const right  = Math.floor((px + w / 2) / TILE);
    const top    = Math.floor((py - h) / TILE);
    const bottom = Math.floor((py) / TILE);
    for (let ty = top; ty <= bottom; ty++) {
      for (let tx = left; tx <= right; tx++) {
        if (isSolidBlock(getBlock(tx, ty))) {
          return true;
        }
      }
    }
    return false;
  }

  function stepPlayer(dt) {
    // horizontal
    player.vx = 0;
    if (keys.left) player.vx -= MOVE_SPEED;
    if (keys.right) player.vx += MOVE_SPEED;

    player.vy += GRAV * dt;

    let newX = player.x + player.vx * dt;
    let newY = player.y + player.vy * dt;

    // horizontal collision
    if (!rectVsWorldCollide(newX, player.y, player.w, player.h)) {
      player.x = newX;
    } else {
      // slide until not colliding
      while (!rectVsWorldCollide(player.x + Math.sign(player.vx), player.y, player.w, player.h)) {
        player.x += Math.sign(player.vx);
      }
      player.vx = 0;
    }

    // vertical collision
    let wasOnGround = player.onGround;
    player.onGround = false;
    if (!rectVsWorldCollide(player.x, newY, player.w, player.h)) {
      player.y = newY;
    } else {
      // move step-by-step
      const step = Math.sign(player.vy);
      while (!rectVsWorldCollide(player.x, player.y + step, player.w, player.h)) {
        player.y += step;
      }
      if (player.vy > 0) player.onGround = true;
      player.vy = 0;
    }

    // keep inside world bounds horizontally (in pixels)
    const minX = player.w / 2;
    const maxX = WORLD_W * TILE - player.w / 2;
    player.x = Math.max(minX, Math.min(maxX, player.x));

    // if somehow below world, clamp
    const maxY = WORLD_H * TILE;
    player.y = Math.min(maxY, player.y);
  }

  // --- Camera ---
  let camX = 0;
  let camY = 0;

  function updateCamera() {
    const viewW = canvas.width;
    const viewH = canvas.height;

    camX = player.x - viewW / 2;
    camY = player.y - viewH / 2;

    const maxCamX = WORLD_W * TILE - viewW;
    const maxCamY = WORLD_H * TILE - viewH;

    camX = Math.max(0, Math.min(maxCamX, camX));
    camY = Math.max(0, Math.min(maxCamY, camY));
  }

  // --- Mining / placing ---
  const REACH = 5; // tiles

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    // screen -> world pixels
    const wx = sx + camX;
    const wy = sy + camY;

    const tx = Math.floor(wx / TILE);
    const ty = Math.floor(wy / TILE);

    const pxTile = player.x / TILE;
    const pyTile = player.y / TILE;
    const dist = Math.hypot(tx - pxTile, ty - pyTile);

    if (dist > REACH) return; // too far

    if (mode === 'break') {
      const id = getBlock(tx, ty);
      if (id !== AIR) {
        setBlock(tx, ty, AIR);
        if (inventory[id] == null) inventory[id] = 0;
        inventory[id]++;
        updateInventoryUI();
      }
    } else {
      // place
      if (getBlock(tx, ty) === AIR && inventory[selectedBlockType] > 0) {
        // don't place inside player
        const blockPxX = tx * TILE + TILE / 2;
        const blockPxY = ty * TILE + TILE; // block bottom
        if (!rectVsWorldCollide(blockPxX, blockPxY, TILE, TILE)) {
          setBlock(tx, ty, selectedBlockType);
          inventory[selectedBlockType]--;
          updateInventoryUI();
        }
      }
    }
  });

  // --- Drawing ---
  function drawBlock(id, x, y) {
    switch (id) {
      case GRASS:
        ctx.fillStyle = '#5da130';
        ctx.fillRect(x, y, TILE, TILE / 3);
        ctx.fillStyle = '#8b5a2b';
        ctx.fillRect(x, y + TILE / 3, TILE, 2 * TILE / 3);
        break;
      case DIRT:
        ctx.fillStyle = '#8b5a2b';
        ctx.fillRect(x, y, TILE, TILE);
        break;
      case STONE:
        ctx.fillStyle = '#777';
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = '#888';
        ctx.fillRect(x + 6, y + 6, TILE / 3, TILE / 3);
        break;
      case WOOD:
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x + 8, y, TILE - 16, TILE);
        break;
      case LEAF:
        ctx.fillStyle = '#2e8b57';
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
        break;
    }
  }

  function render() {
    // sky
    ctx.fillStyle = '#87ceeb';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // clouds (simple)
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillRect(60 - camX * 0.2, 40, 80, 20);
    ctx.fillRect(260 - camX * 0.15, 60, 90, 22);

    // world
    const startTx = Math.floor(camX / TILE);
    const endTx = Math.ceil((camX + canvas.width) / TILE);
    const startTy = Math.floor(camY / TILE);
    const endTy = Math.ceil((camY + canvas.height) / TILE);

    for (let ty = startTy; ty < endTy; ty++) {
      for (let tx = startTx; tx < endTx; tx++) {
        const id = getBlock(tx, ty);
        if (id === AIR) continue;
        const sx = tx * TILE - camX;
        const sy = ty * TILE - camY;
        drawBlock(id, sx, sy);
      }
    }

    // player
    const px = player.x - camX;
    const py = player.y - camY;
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(px - player.w / 2, py - player.h, player.w, player.h);

    // simple "head"
    ctx.fillStyle = '#fff';
    ctx.fillRect(px - player.w / 4, py - player.h + 4, player.w / 2, player.h / 3);
    ctx.fillStyle = '#000';
    ctx.fillRect(px - player.w / 6, py - player.h + 8, 3, 3);
    ctx.fillRect(px + player.w / 10, py - player.h + 8, 3, 3);
  }

  // --- Game loop ---
  let lastTime = performance.now();
  function loop(now) {
    const dt = Math.min(0.035, (now - lastTime) / 1000); // clamp dt
    lastTime = now;

    stepPlayer(dt);
    updateCamera();
    render();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
</script>
</body>
</html>
